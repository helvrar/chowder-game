<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Chowder's Singapore Adventure</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    background: #111;
    width: 100%; height: 100%;
    overflow: hidden;
    font-family: monospace;
    color: #e0e0e0;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
    -webkit-touch-callout: none;
  }
  body {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    height: 100dvh;
  }
  canvas {
    image-rendering: pixelated; image-rendering: crisp-edges;
    display: block;
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
  }
  #controls { position: fixed; bottom: 4px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #666; z-index: 5; }
  #touch-ui {
    display: none;
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 130px;
    pointer-events: none;
    z-index: 10;
    padding-bottom: env(safe-area-inset-bottom, 0);
  }
  #touch-ui.active { display: flex; justify-content: space-between; align-items: flex-end; padding: 0 20px 20px; padding-bottom: calc(20px + env(safe-area-inset-bottom, 0)); }
  .touch-btn {
    pointer-events: auto;
    width: 64px; height: 64px;
    border-radius: 50%;
    background: rgba(255,255,255,0.18);
    border: 2px solid rgba(255,255,255,0.35);
    display: flex; align-items: center; justify-content: center;
    font-size: 28px; color: rgba(255,255,255,0.75);
    -webkit-tap-highlight-color: transparent;
    transition: background 0.05s;
  }
  .touch-btn:active, .touch-btn.pressed { background: rgba(255,255,255,0.45); }
  #dpad { display: flex; flex-direction: column; gap: 8px; }
  #btn-attack {
    width: 84px; height: 84px; font-size: 17px; font-weight: bold;
    background: rgba(240,192,64,0.3);
    border-color: rgba(240,192,64,0.55);
    color: rgba(240,192,64,0.9);
  }
  #name-popup {
    display: none;
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.92);
    z-index: 200;
    flex-direction: column;
    align-items: center; justify-content: center;
    font-family: monospace; text-align: center;
  }
  #name-popup.active { display: flex; }
  #name-popup h2 { color: #f0c040; font-size: 22px; margin-bottom: 8px; }
  #name-popup p { color: #aaa; font-size: 13px; margin-bottom: 18px; }
  #name-popup input {
    background: #222; border: 2px solid #f0c040; color: #fff;
    font-family: monospace; font-size: 20px; text-align: center;
    padding: 8px 12px; width: 200px; max-width: 80vw;
    text-transform: uppercase; letter-spacing: 3px;
    outline: none; border-radius: 4px;
    touch-action: auto; user-select: auto; -webkit-user-select: auto;
  }
  #name-popup input::placeholder { color: #555; text-transform: none; letter-spacing: 0; }
  #name-popup button {
    margin-top: 14px; padding: 10px 30px;
    background: #f0c040; color: #111; border: none;
    font-family: monospace; font-size: 16px; font-weight: bold;
    cursor: pointer; border-radius: 4px;
  }
  #name-popup button:active { background: #d4a830; }
  #rotate-prompt {
    display: none;
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: #111;
    z-index: 100;
    flex-direction: column;
    align-items: center; justify-content: center;
    color: #f0c040; font-family: monospace; font-size: 18px; text-align: center;
  }
  #rotate-prompt .icon { font-size: 60px; margin-bottom: 16px; }
  @media (max-width: 900px) and (orientation: portrait) {
    #rotate-prompt { display: flex !important; }
  }
  @media (min-width: 800px) and (hover: hover) {
    #touch-ui.active { display: none; }
  }
  #music-toggle {
    position: fixed; top: 42px; right: 12px; z-index: 50;
    width: 40px; height: 40px; border-radius: 50%;
    background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.35);
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer; color: #fff;
    -webkit-tap-highlight-color: transparent; pointer-events: auto;
  }
  #music-toggle:hover { background: rgba(0,0,0,0.9); border-color: #f0c040; }
  #music-toggle:active { background: rgba(255,255,255,0.2); }
</style>
</head>
<body>
<div id="name-popup">
  <h2>ENTER YOUR NAME</h2>
  <p>3 letters, arcade style!</p>
  <input type="text" id="name-input" maxlength="3" placeholder="AAA" autocomplete="off" autocapitalize="characters">
  <button id="name-ok">START</button>
</div>
<div id="rotate-prompt"><div class="icon">üì±‚Ü™Ô∏è</div>Rotate your phone sideways<br>to play!</div>
<canvas id="game" width="800" height="500"></canvas>
<div id="controls">Arrows: Move | Space: Bark Attack | R: Restart</div>
<div id="touch-ui">
  <div id="dpad">
    <div class="touch-btn" id="btn-up">&#9650;</div>
    <div class="touch-btn" id="btn-down">&#9660;</div>
  </div>
  <div class="touch-btn" id="btn-attack">BARK</div>
</div>
<div id="music-toggle">&#127925;</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = 800, H = 500;

  // ============================================================
  // RESPONSIVE CANVAS
  // ============================================================
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || ('ontouchstart' in window);
  const touchUI = document.getElementById('touch-ui');
  const controlsDiv = document.getElementById('controls');
  if (isMobile) { touchUI.classList.add('active'); controlsDiv.style.display = 'none'; }

  // ============================================================
  // AUDIO ENGINE - iOS/mobile unlock using HTML Audio + WebAudio
  // Based on proven patterns from unmute-ios-audio library
  // ============================================================
  let musicPlaying = false, musicInterval = null;

  // Step 1: Create AudioContext EAGERLY at page load (before gestures)
  const AC = window.AudioContext || window.webkitAudioContext;
  let audioCtx = AC ? new AC() : null;

  // Step 2: Create a tiny silent WAV as a data URI for HTML <audio> trick
  // This is a valid 44-byte WAV file: 1 sample of silence
  const silentDataURI = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
  const silentAudio = document.createElement('audio');
  silentAudio.setAttribute('playsinline', '');
  silentAudio.src = silentDataURI;

  // Step 3: Unlock function ‚Äî called on EVERY user gesture
  // Uses THREE strategies simultaneously for maximum iOS compatibility:
  // 1. audioCtx.resume()
  // 2. HTML <audio> element .play()
  // 3. WebAudio oscillator playback
  function unlockAudio() {
    if (!audioCtx) return;
    // Strategy 1: Resume the AudioContext
    if (audioCtx.state !== 'running') {
      audioCtx.resume();
    }
    // Strategy 2: Play silent audio via HTML <audio> element
    // This is what actually unlocks audio on many iOS versions
    try { silentAudio.play().catch(function(){}); } catch(e) {}
    // Strategy 3: Play a tiny oscillator through WebAudio
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = 0.001;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(0); o.stop(audioCtx.currentTime + 0.001);
    } catch(e) {}
  }

  // Attach to ALL user gesture events ‚Äî both touchstart AND touchend
  // (some iOS versions only unlock on touchend, not touchstart)
  ['touchstart','touchend','mousedown','click','keydown'].forEach(evt => {
    document.addEventListener(evt, unlockAudio, { capture: true, passive: true });
  });

  // Handle iOS backgrounding/foregrounding
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && audioCtx && audioCtx.state !== 'running') {
      audioCtx.resume();
    }
  });

  // Helper: check if audio is ready to play
  function audioReady() {
    if (!audioCtx) return false;
    if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
      audioCtx.resume();
      return false;
    }
    return audioCtx.state === 'running';
  }

  // --- BARK: multi-osc with formant-like bandpass ---
  function playBark() {
    if (!audioReady()) return;
    const t = audioCtx.currentTime;
    // Tonal component ‚Äî sawtooth sweep
    const osc1 = audioCtx.createOscillator(); osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(420, t);
    osc1.frequency.exponentialRampToValueAtTime(200, t + 0.08);
    osc1.frequency.exponentialRampToValueAtTime(350, t + 0.13);
    osc1.frequency.exponentialRampToValueAtTime(150, t + 0.28);
    // Bandpass to shape it
    const bp1 = audioCtx.createBiquadFilter(); bp1.type = 'bandpass';
    bp1.frequency.setValueAtTime(800, t);
    bp1.frequency.exponentialRampToValueAtTime(400, t + 0.12);
    bp1.frequency.exponentialRampToValueAtTime(250, t + 0.3);
    bp1.Q.value = 2;
    // Second formant ‚Äî higher
    const osc2 = audioCtx.createOscillator(); osc2.type = 'sawtooth';
    osc2.frequency.setValueAtTime(840, t);
    osc2.frequency.exponentialRampToValueAtTime(500, t + 0.1);
    osc2.frequency.exponentialRampToValueAtTime(300, t + 0.25);
    const bp2 = audioCtx.createBiquadFilter(); bp2.type = 'bandpass';
    bp2.frequency.setValueAtTime(1600, t);
    bp2.frequency.exponentialRampToValueAtTime(1000, t + 0.15);
    bp2.Q.value = 1.5;
    const g2 = audioCtx.createGain(); g2.gain.value = 0.15;
    // Envelope
    const env = audioCtx.createGain();
    env.gain.setValueAtTime(0.001, t);
    env.gain.linearRampToValueAtTime(0.55, t + 0.012);
    env.gain.linearRampToValueAtTime(0.4, t + 0.06);
    env.gain.linearRampToValueAtTime(0.25, t + 0.15);
    env.gain.exponentialRampToValueAtTime(0.001, t + 0.32);
    osc1.connect(bp1); bp1.connect(env);
    osc2.connect(bp2); bp2.connect(g2); g2.connect(env);
    env.connect(audioCtx.destination);
    osc1.start(t); osc1.stop(t + 0.35);
    osc2.start(t); osc2.stop(t + 0.35);
  }

  // --- WHIMPER: descending sine tones with vibrato ---
  function playWhimper() {
    if (!audioReady()) return;
    const t = audioCtx.currentTime;
    for (let i = 0; i < 3; i++) {
      const st = t + i * 0.13;
      const osc = audioCtx.createOscillator(); osc.type = 'sine';
      const f = 900 - i * 120;
      osc.frequency.setValueAtTime(f, st);
      osc.frequency.exponentialRampToValueAtTime(f * 0.45, st + 0.12);
      // Vibrato LFO
      const lfo = audioCtx.createOscillator(); lfo.frequency.value = 28;
      const lfoG = audioCtx.createGain(); lfoG.gain.value = 30;
      lfo.connect(lfoG); lfoG.connect(osc.frequency);
      lfo.start(st); lfo.stop(st + 0.13);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.001, st);
      g.gain.linearRampToValueAtTime(0.22, st + 0.015);
      g.gain.exponentialRampToValueAtTime(0.001, st + 0.12);
      osc.connect(g); g.connect(audioCtx.destination);
      osc.start(st); osc.stop(st + 0.13);
    }
  }

  // --- BURP: low rumble with gurgle LFO ---
  function playBurp() {
    if (!audioReady()) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator(); osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(120, t);
    osc.frequency.exponentialRampToValueAtTime(55, t + 0.15);
    osc.frequency.exponentialRampToValueAtTime(80, t + 0.22);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.38);
    // Gurgle wobble
    const lfo = audioCtx.createOscillator(); lfo.frequency.value = 14;
    const lfoG = audioCtx.createGain(); lfoG.gain.value = 25;
    lfo.connect(lfoG); lfoG.connect(osc.frequency);
    lfo.start(t); lfo.stop(t + 0.42);
    // Lowpass for warmth
    const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass';
    lp.frequency.setValueAtTime(300, t);
    lp.frequency.exponentialRampToValueAtTime(100, t + 0.3);
    lp.Q.value = 6;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.001, t);
    g.gain.linearRampToValueAtTime(0.5, t + 0.025);
    g.gain.linearRampToValueAtTime(0.35, t + 0.15);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
    osc.connect(lp); lp.connect(g); g.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.42);
  }

  // --- KO: impact thud ---
  function playKO() {
    if (!audioReady()) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator(); osc.type = 'sine';
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.45, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    osc.connect(g); g.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.35);
  }

  // --- HIT: lighter tap ---
  function playHit() {
    if (!audioReady()) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator(); osc.type = 'triangle';
    osc.frequency.setValueAtTime(300, t);
    osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.3, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    osc.connect(g); g.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.18);
  }

  // --- MUSIC: real-time scheduled chiptune ---
  function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }
  // Level 1 music - bright major key (Singapore)
  const melodyL1 = [72,72,74,76, 76,74,72,71, 69,69,71,72, 72,71,71,0, 72,72,74,76, 76,74,72,71, 69,69,71,72, 71,69,69,0];
  const bassL1 =   [48,0,48,0, 45,0,45,0, 43,0,43,0, 45,0,47,0, 48,0,48,0, 45,0,45,0, 43,0,43,0, 45,0,45,0];
  // Level 2 music - pentatonic/minor feel (Shanghai)
  const melodyL2 = [76,74,71,69, 67,69,71,74, 76,0,74,71, 69,67,69,0, 71,74,76,79, 76,74,71,69, 67,69,71,0, 74,71,69,0];
  const bassL2 =   [45,0,45,48, 43,0,43,0, 45,0,48,0, 43,0,40,0, 45,0,45,48, 43,0,43,0, 45,0,48,0, 43,0,43,0];
  // Level 3 music - tarantella/Italian folk feel (Milan)
  const melodyL3 = [72,74,76,79, 79,76,74,72, 71,74,76,0, 79,76,74,72, 72,74,76,79, 81,79,76,74, 72,74,76,0, 74,72,71,0];
  const bassL3 =   [48,0,52,0, 48,0,52,0, 47,0,50,0, 47,0,50,0, 45,0,48,0, 45,0,48,0, 43,0,47,0, 43,0,48,0];
  let melodyNotes = melodyL1, bassNotes = bassL1;
  const BPM = 280, BEAT_LEN = 60 / BPM;
  let musicBeatIdx = 0, nextBeatTime = 0;

  function scheduleMusicBeat(t) {
    if (!audioCtx) return;
    const i = musicBeatIdx % melodyNotes.length;
    try {
      if (melodyNotes[i] !== 0) {
        const osc = audioCtx.createOscillator(); osc.type = 'square';
        osc.frequency.value = midiToFreq(melodyNotes[i]);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.1, t);
        g.gain.setValueAtTime(0.1, t + BEAT_LEN * 0.75);
        g.gain.linearRampToValueAtTime(0.0, t + BEAT_LEN * 0.9);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + BEAT_LEN);
      }
      if (bassNotes[i] !== 0) {
        const osc = audioCtx.createOscillator(); osc.type = 'triangle';
        osc.frequency.value = midiToFreq(bassNotes[i]);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.12, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + BEAT_LEN * 0.85);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + BEAT_LEN);
      }
      if (i % 2 === 0) {
        const osc = audioCtx.createOscillator(); osc.type = 'sine';
        osc.frequency.setValueAtTime(140, t);
        osc.frequency.exponentialRampToValueAtTime(35, t + 0.08);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.15, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + 0.12);
      }
    } catch(e) {} // Silently skip if audio node creation fails
    musicBeatIdx++;
  }

  function startMusic() {
    if (!musicEnabled) return;
    if (musicPlaying) return;
    if (!audioCtx) return;
    musicPlaying = true;
    musicBeatIdx = 0;
    // Simple approach: schedule one beat at a time, no while loop
    musicInterval = setInterval(() => {
      if (!musicPlaying || !audioCtx) return;
      if (audioCtx.state !== 'running') return; // Skip silently, no loops
      try {
        const t = audioCtx.currentTime + 0.05; // Schedule slightly ahead
        scheduleMusicBeat(t);
      } catch(e) {}
    }, Math.round(BEAT_LEN * 1000)); // Fire once per beat
  }
  function stopMusic() {
    musicPlaying = false;
    if (musicInterval) { clearInterval(musicInterval); musicInterval = null; }
  }

  // --- MUSIC TOGGLE ---
  let musicEnabled = true;
  try { musicEnabled = localStorage.getItem('chowder_musicEnabled') !== 'false'; } catch(e) {}

  const musicToggleBtn = document.getElementById('music-toggle');
  function updateMusicIcon() { musicToggleBtn.textContent = musicEnabled ? '\u{1F3B5}' : '\u{1F507}'; }
  updateMusicIcon();

  function toggleMusic(e) {
    if (e) { e.preventDefault(); e.stopPropagation(); }
    unlockAudio();
    musicEnabled = !musicEnabled;
    try { localStorage.setItem('chowder_musicEnabled', musicEnabled); } catch(e2) {}
    updateMusicIcon();
    if (musicEnabled) { if (gameState === 'playing') startMusic(); }
    else { stopMusic(); }
  }
  musicToggleBtn.addEventListener('click', toggleMusic);
  musicToggleBtn.addEventListener('touchend', toggleMusic);

  // ============================================================
  // PIXEL DRAWING
  // ============================================================
  function px(pixels, x, y, s, colorMap) {
    for (let r = 0; r < pixels.length; r++) {
      for (let c = 0; c < pixels[r].length; c++) {
        let col = pixels[r][c];
        if (col) {
          if (colorMap && colorMap[col]) col = colorMap[col];
          ctx.fillStyle = col;
          ctx.fillRect(Math.round(x + c * s), Math.round(y + r * s), Math.ceil(s), Math.ceil(s));
        }
      }
    }
  }

  // ============================================================
  // CHOWDER SPRITE - with bigger droopy brown ears
  // ============================================================
  const _ = null;
  const A = '#F5E6C8', B = '#E8D4A8', C = '#D4A050', D = '#C48830';
  const EY = '#1a1a1a', NS = '#222', TG = '#FF6B8A', WH = '#FFF8F0';
  const ER = '#8B5E3C', E2 = '#6B4226'; // Ear colors - brown

  const chowderR1 = [
    [_,_,_,ER,ER,_,C,C,C,_,_,_,_,_,_,_,_,_,_,_],
    [_,_,ER,ER,ER,C,A,A,C,C,_,_,_,_,_,_,_,_,_,_],
    [_,ER,E2,ER,C,A,WH,A,A,C,C,_,_,_,_,_,_,_,_,_],
    [_,ER,ER,C,C,A,A,A,A,A,C,C,_,_,_,_,_,_,_,_],
    [_,_,ER,C,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_,_],
    [_,_,_,C,B,A,EY,A,A,EY,A,A,B,C,_,_,_,_,_,_],
    [_,_,_,_,C,A,A,A,A,A,A,A,A,C,_,_,_,_,_,_],
    [_,_,_,_,C,B,A,A,NS,NS,A,A,A,C,_,_,_,_,_,_],
    [_,_,_,_,_,C,A,A,A,A,TG,C,C,_,_,_,_,_,_,_],
    [_,_,_,_,C,B,A,A,A,A,A,B,C,_,_,_,_,_,_,_],
    [_,_,_,C,A,WH,A,A,A,WH,A,A,C,_,_,_,_,_,_,_],
    [_,_,C,B,A,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_],
    [_,C,A,A,WH,A,A,A,A,A,WH,A,A,C,_,_,_,_,_,_],
    [_,C,B,A,A,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_],
    [_,_,C,B,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_,_],
    [_,_,_,C,C,A,A,A,A,A,C,C,_,_,_,D,C,_,_,_],
    [_,_,_,C,D,C,_,_,_,C,D,C,_,_,D,C,D,C,_,_],
    [_,_,C,D,_,C,_,_,_,C,_,D,C,_,C,D,C,D,C,_],
    [_,_,C,C,_,_,_,_,_,_,_,C,C,_,_,C,D,C,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,C,_,_,_],
  ];
  const chowderR2 = [
    [_,_,_,ER,ER,_,C,C,C,_,_,_,_,_,_,_,_,_,_,_],
    [_,_,ER,ER,ER,C,A,A,C,C,_,_,_,_,_,_,_,_,_,_],
    [_,ER,E2,ER,C,A,WH,A,A,C,C,_,_,_,_,_,_,_,_,_],
    [_,ER,ER,C,C,A,A,A,A,A,C,C,_,_,_,_,_,_,_,_],
    [_,_,ER,C,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_,_],
    [_,_,_,C,B,A,EY,A,A,EY,A,A,B,C,_,_,_,_,_,_],
    [_,_,_,_,C,A,A,A,A,A,A,A,A,C,_,_,_,_,_,_],
    [_,_,_,_,C,B,A,A,NS,NS,A,A,A,C,_,_,_,_,_,_],
    [_,_,_,_,_,C,A,A,A,A,TG,C,C,_,_,_,_,_,_,_],
    [_,_,_,_,C,B,A,A,A,A,A,B,C,_,_,_,_,_,_,_],
    [_,_,_,C,A,WH,A,A,A,WH,A,A,C,_,_,_,_,_,_,_],
    [_,_,C,B,A,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_],
    [_,C,A,A,WH,A,A,A,A,A,WH,A,A,C,_,_,_,_,_,_],
    [_,C,B,A,A,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_],
    [_,_,C,B,A,A,A,A,A,A,A,B,C,_,_,D,_,_,_,_],
    [_,_,_,C,C,A,A,A,A,A,C,C,_,_,D,C,D,_,_,_],
    [_,_,C,D,_,C,_,_,_,C,_,D,C,_,C,D,C,D,_,_],
    [_,_,_,C,D,C,_,_,_,C,D,C,_,_,D,C,D,C,_,_],
    [_,_,_,C,C,_,_,_,_,_,C,C,_,_,_,C,C,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
  ];
  const chowderAtk = [
    [_,_,_,ER,ER,_,C,C,C,_,_,_,_,_,_,_,_,_,_,_],
    [_,_,ER,ER,ER,C,A,A,C,C,_,_,_,_,_,_,_,_,_,_],
    [_,ER,E2,ER,C,A,WH,A,A,C,C,_,_,_,_,_,_,_,_,_],
    [_,ER,ER,C,C,A,A,A,A,A,C,C,C,_,_,_,_,_,_,_],
    [_,_,ER,C,A,A,A,A,A,A,A,B,A,C,_,_,_,_,_,_],
    [_,_,_,C,B,A,EY,A,A,EY,A,A,A,B,C,_,_,_,_,_],
    [_,_,_,_,C,A,A,A,A,A,A,A,NS,NS,C,_,_,_,_,_],
    [_,_,_,_,C,B,A,A,A,A,A,A,A,C,_,_,_,_,_,_],
    [_,_,_,_,_,C,A,A,TG,TG,TG,TG,C,_,_,_,_,_,_,_],
    [_,_,_,_,C,B,A,A,A,A,A,B,C,_,_,_,_,_,_,_],
    [_,_,_,C,A,WH,A,A,A,WH,A,A,C,_,_,_,_,_,_,_],
    [_,_,C,B,A,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_],
    [_,C,A,A,WH,A,A,A,A,A,WH,A,A,C,_,_,_,_,_,_],
    [_,C,B,A,A,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_],
    [_,_,C,B,A,A,A,A,A,A,A,B,C,_,_,_,_,_,_,_],
    [_,_,_,C,C,A,A,A,A,A,C,C,_,_,D,C,_,_,_,_],
    [_,_,C,D,_,C,_,_,_,C,_,D,C,D,C,D,C,_,_,_],
    [_,_,_,C,D,C,_,_,_,C,D,C,_,C,D,C,_,_,_,_],
    [_,_,_,C,C,_,_,_,_,_,C,C,_,_,C,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
  ];
  const chowderFrames = [chowderR1, chowderR2];

  // ============================================================
  // ENEMY DOG SPRITE
  // ============================================================
  const O1 = '#E8860C', O2 = '#D47000', O3 = '#FFF5E0', O4 = '#F5C040', OE = '#1a1a1a', ON = '#222';

  const dogL1 = [
    [_,_,_,_,_,_,_,_,_,_,_,O1,O1,_,_,_,O1,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O4,O1,_,O1,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,_,O1,O4,O4,O4,O1,O4,O4,O1,_],
    [_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O3,O4,O1,_],
    [_,_,_,_,_,_,_,O1,O3,O3,O3,O3,O3,O3,O3,O1,_,_],
    [_,_,_,_,_,_,O1,O3,OE,O3,O3,O3,OE,O3,O1,_,_,_],
    [_,_,_,_,_,_,_,O1,O3,O3,O3,O3,O3,O1,_,_,_,_],
    [_,_,_,_,_,_,_,O1,O3,ON,ON,O3,O1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,O1,O3,O3,O1,_,_,_,_,_,_],
    [_,_,_,_,_,_,O1,O1,O4,O4,O4,O4,O1,_,_,_,_,_],
    [_,_,_,_,_,O1,O4,O4,O3,O3,O3,O4,O4,O1,_,_,_,_],
    [_,_,_,_,O1,O4,O4,O3,O3,O3,O3,O3,O4,O4,O1,_,_,_],
    [_,_,_,O1,O4,O1,O4,O3,O3,O3,O3,O3,O4,O1,O4,O1,_,_],
    [_,_,_,O1,O4,_,O1,O4,O4,O4,O4,O4,O1,_,O4,O1,_,_],
    [_,_,_,_,O1,_,_,O1,O1,O1,O1,O1,_,_,O1,_,_,_],
    [_,O2,O1,O1,O2,_,_,_,_,_,_,_,_,_,O2,O1,_,_],
    [O1,O2,O1,_,O1,_,_,_,_,_,_,_,_,_,O1,O1,_,_],
    [_,O1,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
  ];
  const dogL2 = [
    [_,_,_,_,_,_,_,_,_,_,_,O1,O1,_,_,_,O1,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O4,O1,_,O1,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,_,O1,O4,O4,O4,O1,O4,O4,O1,_],
    [_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O3,O4,O1,_],
    [_,_,_,_,_,_,_,O1,O3,O3,O3,O3,O3,O3,O3,O1,_,_],
    [_,_,_,_,_,_,O1,O3,OE,O3,O3,O3,OE,O3,O1,_,_,_],
    [_,_,_,_,_,_,_,O1,O3,O3,O3,O3,O3,O1,_,_,_,_],
    [_,_,_,_,_,_,_,O1,O3,ON,ON,O3,O1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,O1,O3,O3,O1,_,_,_,_,_,_],
    [_,_,_,_,_,_,O1,O1,O4,O4,O4,O4,O1,_,_,_,_,_],
    [_,_,_,_,_,O1,O4,O4,O3,O3,O3,O4,O4,O1,_,_,_,_],
    [_,_,_,_,O1,O4,O4,O3,O3,O3,O3,O3,O4,O4,O1,_,_,_],
    [_,_,_,O1,O4,O1,O4,O3,O3,O3,O3,O3,O4,O1,O4,O1,_,_],
    [_,_,_,O1,O4,_,O1,O4,O4,O4,O4,O4,O1,_,O4,O1,_,_],
    [_,_,_,_,O1,_,_,O1,O1,O1,O1,O1,_,_,O1,_,_,_],
    [_,O2,O1,_,O2,O1,_,_,_,_,_,_,_,O1,O2,_,_,_],
    [O1,O2,O1,_,O1,O1,_,_,_,_,_,_,_,O1,O1,_,_,_],
    [_,O1,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
  ];
  const dogFrames = [dogL1, dogL2];

  const DOG_COLORS = {
    orange: {},
    black: { [O1]: '#2a2a2a', [O2]: '#1a1a1a', [O3]: '#555', [O4]: '#3a3a3a' },
    white: { [O1]: '#ccc', [O2]: '#aaa', [O3]: '#fff', [O4]: '#e8e8e8' },
  };
  const DOG_VARIANT_KEYS = ['orange', 'black', 'white'];

  // ============================================================
  // CAT SPRITE (Level 2 - stray cats)
  // ============================================================
  const catL1 = [
    [_,_,_,_,_,_,_,_,_,_,_,_,O1,_,_,_,_,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,O1,O4,O1,_,O1,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O3,O3,O3,O1,O3,O3,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O3,OE,O3,O3,OE,O3,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,O1,O3,O3,O3,O3,O1,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,O1,O3,ON,O3,O1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O4,O4,O4,O4,O4,O1,_,_,_],
    [_,_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O4,O1,_,_,_],
    [_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O3,O3,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O3,O3,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,O1,O4,O4,O4,O4,O4,O4,O4,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,_,O1,O4,_,_,_,_,O4,O1,_,_,_],
    [_,O1,O1,_,_,_,_,_,_,O1,O1,_,_,_,_,O1,O1,_,_,_],
    [_,_,O1,O1,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
    [_,_,_,O1,O4,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
    [_,_,_,_,O1,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
  ];
  const catL2 = [
    [_,_,_,_,_,_,_,_,_,_,_,_,O1,_,_,_,_,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,O1,O4,O1,_,O1,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O3,O3,O3,O1,O3,O3,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O3,OE,O3,O3,OE,O3,O1,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,O1,O3,O3,O3,O3,O1,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,O1,O3,ON,O3,O1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,O1,O4,O4,O4,O4,O4,O1,_,_,_],
    [_,_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O4,O1,_,_,_],
    [_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O3,O3,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,O1,O4,O3,O3,O3,O3,O3,O3,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,O1,O4,O4,O4,O4,O4,O4,O4,O4,O1,_,_],
    [_,_,_,_,_,_,_,_,_,O1,_,O4,_,_,O4,_,O1,_,_,_],
    [_,_,O1,_,_,_,_,_,_,O1,O1,_,_,_,_,O1,O1,_,_,_],
    [_,O1,O4,O1,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
    [_,_,O1,O1,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
    [_,_,_,O1,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_],
  ];
  const catFrames = [catL1, catL2];
  const CAT_COLORS = {
    orange: {},
    gray: { [O1]: '#808080', [O2]: '#606060', [O3]: '#c0c0c0', [O4]: '#a0a0a0' },
    black: { [O1]: '#2a2a2a', [O2]: '#1a1a1a', [O3]: '#555', [O4]: '#3a3a3a' },
    calico: { [O1]: '#E8860C', [O2]: '#fff', [O3]: '#FFF5E0', [O4]: '#2a2a2a' },
  };
  const CAT_VARIANT_KEYS = ['orange', 'gray', 'black', 'calico'];
  const CAT_S = 3;

  // ============================================================
  // DELIVERY RIDER SPRITE (Level 2 - e-scooter)
  // ============================================================
  const R1='#2060d0',R2='#1848a0',R3='#ddd',R4='#888',R5='#333',RH='#f0d0a0';
  const riderL1 = [
    [_,_,_,_,_,_,_,_,_,_,_,_,RH,RH,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,RH,RH,RH,RH,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,R1,RH,RH,R1,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,R1,R2,R1,R1,R1,R2,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,R1,R2,R1,R1,R1,R2,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R5,R1,R1,R1,R5,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R5,R5,_,R5,R5,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,R4,R4,R4,R4,R4,R4,R4,_,_,_,_,_],
    [_,_,_,_,_,_,_,R4,R3,R3,R3,R3,R3,R3,R3,R4,_,_,_,_],
    [_,_,_,_,_,_,R5,R4,R3,R3,R3,R3,R3,R3,R3,R4,R5,_,_,_],
    [_,_,_,_,_,R5,_,R4,R4,R4,R4,R4,R4,R4,R4,R4,_,R5,_,_],
    [_,_,_,_,R5,R4,R5,_,_,_,_,_,_,_,_,_,R5,R4,R5,_],
    [_,_,_,R5,R4,R4,R4,R5,_,_,_,_,_,_,R5,R4,R4,R4,R5,_],
    [_,_,_,_,R5,R5,R5,_,_,_,_,_,_,_,_,R5,R5,R5,_,_],
  ];
  const riderL2 = [
    [_,_,_,_,_,_,_,_,_,_,_,_,RH,RH,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,RH,RH,RH,RH,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,R1,RH,RH,R1,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,R1,R2,R1,R1,R1,R2,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,R1,R2,R1,R1,R1,R2,R1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R1,R1,R1,R1,R1,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R5,R1,R1,R1,R5,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,R5,R5,_,R5,R5,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,R4,R4,R4,R4,R4,R4,R4,_,_,_,_,_],
    [_,_,_,_,_,_,_,R4,R3,R3,R3,R3,R3,R3,R3,R4,_,_,_,_],
    [_,_,_,_,_,_,R5,R4,R3,R3,R3,R3,R3,R3,R3,R4,R5,_,_,_],
    [_,_,_,_,_,R5,_,R4,R4,R4,R4,R4,R4,R4,R4,R4,_,R5,_,_],
    [_,_,_,_,_,R5,R4,R5,_,_,_,_,_,_,_,R5,R4,R5,_,_],
    [_,_,_,_,R5,R4,R4,R4,R5,_,_,_,_,R5,R4,R4,R4,R5,_,_],
    [_,_,_,_,_,R5,R5,R5,_,_,_,_,_,_,R5,R5,R5,_,_,_],
  ];
  const riderFrames = [riderL1, riderL2];
  const RIDER_COLORS = {
    blue: {},
    yellow: { [R1]: '#e8c020', [R2]: '#c8a010' },
  };
  const RIDER_VARIANT_KEYS = ['blue', 'yellow'];
  const RIDER_S = 3.5;

  // ============================================================
  // ULTRA FAN SPRITE (Level 3 - AC/Inter ultras)
  // ============================================================
  const U1='#222',U2='#444',U3='#ddd',UH='#f0c8a0',UE='#111';
  const ultraL1 = [
    [_,_,_,_,_,_,_,_,_,_,_,_,UH,UH,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,UH,UH,UH,UH,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,UH,UE,UH,UH,UE,UH,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,UH,UH,UH,UH,UH,UH,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,UH,U1,UH,UH,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U1,U1,U1,U1,U1,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U1,U2,U1,U1,U1,U2,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U1,U2,U1,U1,U1,U2,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U1,U1,U1,U1,U1,U1,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U1,U1,U1,U1,U1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U1,U3,U1,U3,U1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U2,_,_,_,U2,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U2,U2,_,_,_,U2,U2,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U2,_,_,_,U2,_,_,_,_,_],
  ];
  const ultraL2 = [
    [_,_,_,_,_,_,_,_,_,_,_,_,UH,UH,_,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,UH,UH,UH,UH,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,UH,UE,UH,UH,UE,UH,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,UH,UH,UH,UH,UH,UH,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,_,UH,U1,UH,UH,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U1,U1,U1,U1,U1,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U1,U2,U1,U1,U1,U2,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U1,U2,U1,U1,U1,U2,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U1,U1,U1,U1,U1,U1,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U1,U1,U1,U1,U1,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U1,U3,_,U1,_,U3,U1,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U2,_,_,_,U2,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,_,U2,U2,_,U2,U2,_,_,_,_,_],
    [_,_,_,_,_,_,_,_,_,U2,U2,_,_,_,U2,U2,_,_,_,_],
  ];
  const ultraFrames = [ultraL1, ultraL2];
  const ULTRA_COLORS = {
    ac: { [U1]: '#e00020', [U2]: '#111' },    // AC Milan: red+black
    inter: { [U1]: '#0040a0', [U2]: '#111' },  // Inter: blue+black
  };
  const ULTRA_VARIANT_KEYS = ['ac', 'inter'];
  const ULTRA_S = 4;

  // ============================================================
  // TRAM SPRITE (Level 3 - Milan street tram, invincible)
  // ============================================================
  const T1='#e8a020',T2='#d08810',T3='#f5d060',T4='#333',T5='#888',T6='#aee8ff';
  const tramL1 = [
    [_,_,_,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,_],
    [_,_,T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4,_],
    [_,T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4],
    [T4,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T1,T4],
    [T4,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T1,T4],
    [T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4],
    [T4,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T4],
    [T4,T1,T3,T3,T1,T3,T3,T1,T3,T3,T1,T3,T3,T1,T3,T3,T1,T3,T1,T4],
    [_,T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4,_],
    [_,_,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,_,_],
    [_,_,T5,T4,T5,_,_,_,_,_,_,_,_,_,_,_,T5,T4,T5,_],
  ];
  const tramL2 = [
    [_,_,_,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,_],
    [_,_,T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4,_],
    [_,T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4],
    [T4,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T1,T4],
    [T4,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T6,T1,T6,T1,T4],
    [T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4],
    [T4,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T2,T4],
    [T4,T1,T3,T3,T1,T3,T3,T1,T3,T3,T1,T3,T3,T1,T3,T3,T1,T3,T1,T4],
    [_,T4,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T4,_],
    [_,_,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,T4,_,_],
    [_,_,_,T5,T4,T5,_,_,_,_,_,_,_,_,_,T5,T4,T5,_,_],
  ];
  const tramFrames = [tramL1, tramL2];
  const TRAM_S = 5;

  // ============================================================
  // CONSTANTS
  // ============================================================
  const FLOOR_TOP = 320, FLOOR_BOT = 440;
  const SCROLL_SPEED = 3.6, PLAYER_X = 140;
  const SPRITE_S = 3.5, DOG_S = 3, THUG_S = 4;

  // ============================================================
  // LEVEL SYSTEM
  // ============================================================
  const SCENES_L1 = [
    { name: 'Marina Bay Sands', draw: drawSceneMBS },
    { name: 'Merlion Park', draw: drawSceneMerlion },
    { name: 'HDB Heartland', draw: drawSceneHDB },
    { name: 'Chinatown', draw: drawSceneChinatown },
    { name: 'Joo Chiat', draw: drawSceneJooChiat },
    { name: 'CBD Financial District', draw: drawSceneCBD },
    { name: 'Hawker Centre', draw: drawSceneHawker },
    { name: 'Botanic Gardens', draw: drawSceneBotanic },
    { name: 'Hiking Trail', draw: drawSceneHiking },
    { name: 'Changi Airport', draw: drawSceneChangi },
    { name: 'Orchard Road Mall', draw: drawSceneMall },
    { name: 'ArtScience Museum', draw: drawSceneArtScience },
    { name: 'East Coast Park', draw: drawSceneEastCoast },
  ];
  const SCENES_L2 = [
    { name: 'The Bund', draw: drawSceneBund },
    { name: 'Pudong Skyline', draw: drawScenePudong },
    { name: 'French Concession', draw: drawSceneFrenchConcession },
    { name: 'Yuyuan Garden', draw: drawSceneYuyuan },
    { name: 'Nanjing East Road', draw: drawSceneNanjingRd },
    { name: 'People\'s Square', draw: drawScenePeoplesSq },
    { name: 'Xintiandi', draw: drawSceneXintiandi },
    { name: 'Jing\'an Temple', draw: drawSceneJingan },
    { name: 'Huaihai Road', draw: drawSceneHuaihai },
    { name: 'Xujiahui', draw: drawSceneXujiahui },
    { name: 'Suzhou Creek', draw: drawSceneSuzhouCreek },
    { name: 'Shanghai Tower', draw: drawSceneSHTower },
    { name: 'Gubei & Hongqiao', draw: drawSceneGubei },
  ];
  const SCENES_L3 = [
    { name: 'Duomo di Milano', draw: drawSceneDuomo },
    { name: 'Galleria Vittorio Emanuele', draw: drawSceneGalleria },
    { name: 'Castello Sforzesco', draw: drawSceneSforzesco },
    { name: 'Arco della Pace', draw: drawSceneArco },
    { name: 'Navigli', draw: drawSceneNavigli },
    { name: 'Brera & Via Montenapoleone', draw: drawSceneBrera },
    { name: 'Stazione Centrale', draw: drawSceneCentrale },
    { name: 'San Siro Stadium', draw: drawSceneSanSiro },
    { name: 'Sant\'Ambrogio', draw: drawSceneSantAmbrogio },
    { name: 'Bosco Verticale', draw: drawSceneBoscoVerticale },
    { name: 'Colonne di San Lorenzo', draw: drawSceneColonne },
    { name: 'Santa Giulia Arena', draw: drawSceneSantaGiulia },
    { name: 'Assago Forum', draw: drawSceneAssago },
  ];
  const LEVELS = [SCENES_L1, SCENES_L2, SCENES_L3];
  const LEVEL_NAMES = ["SINGAPORE", "SHANGHAI", "MILANO"];
  let currentLevel = 0;
  let levelScenes = LEVELS[0];
  const SCENE_W = 600;
  let WORLD_END = levelScenes.length * SCENE_W;

  // ============================================================
  // PLAYER NAME & LEADERBOARD (localStorage + Firebase global)
  // ============================================================
  const FIREBASE_DB_URL = 'https://chowder-game-default-rtdb.asia-southeast1.firebasedatabase.app';
  const LS_NAME_KEY = 'chowder_playerName';
  const LS_BOARD_KEY = 'chowder_leaderboard';
  let playerName = localStorage.getItem(LS_NAME_KEY) || '';
  let leaderboard = [];
  try { leaderboard = JSON.parse(localStorage.getItem(LS_BOARD_KEY)) || []; } catch(e) { leaderboard = []; }

  // Save locally (cache)
  function saveLeaderboard() {
    leaderboard.sort((a, b) => b.score - a.score);
    leaderboard = leaderboard.slice(0, 10);
    try { localStorage.setItem(LS_BOARD_KEY, JSON.stringify(leaderboard)); } catch(e) {}
  }

  // Fetch global top 10 from Firebase
  async function fetchGlobalLeaderboard() {
    try {
      const url = FIREBASE_DB_URL + '/leaderboard.json?orderBy=%22score%22&limitToLast=10';
      const res = await fetch(url);
      if (!res.ok) return;
      const data = await res.json();
      if (!data || typeof data !== 'object') return;
      const entries = Object.values(data);
      if (!entries.length) return;
      entries.sort((a, b) => b.score - a.score);
      leaderboard = entries.slice(0, 10);
      saveLeaderboard();
      if (leaderboard.length > 0 && leaderboard[0].score > hiScore) {
        hiScore = leaderboard[0].score;
      }
    } catch(e) {} // Offline fallback: use local data
  }

  // Push a score to Firebase (fire-and-forget)
  async function pushScoreToGlobal(name, sc) {
    try {
      await fetch(FIREBASE_DB_URL + '/leaderboard.json', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: name.toUpperCase(), score: sc, date: Date.now() })
      });
      await fetchGlobalLeaderboard();
    } catch(e) {} // Offline: score is still saved locally
  }

  function addToLeaderboard(name, sc) {
    leaderboard.push({ name: name.toUpperCase(), score: sc, date: Date.now() });
    saveLeaderboard();
    pushScoreToGlobal(name, sc); // async, non-blocking
  }

  // Load hiScore from local cache
  let storedHi = leaderboard.length > 0 ? leaderboard[0].score : 0;

  // Name popup logic
  const namePopup = document.getElementById('name-popup');
  const nameInput = document.getElementById('name-input');
  const nameOk = document.getElementById('name-ok');
  let nameReady = !!playerName;

  if (!playerName) {
    namePopup.classList.add('active');
    // Allow typing in the name input (override touch-action: none for this element)
    nameInput.style.touchAction = 'auto';
    nameInput.style.userSelect = 'auto';
    nameInput.style.webkitUserSelect = 'auto';
    setTimeout(() => nameInput.focus(), 300);
  }

  function submitName() {
    let n = nameInput.value.replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 3);
    if (!n) n = 'AAA';
    while (n.length < 3) n += 'A';
    playerName = n;
    localStorage.setItem(LS_NAME_KEY, playerName);
    namePopup.classList.remove('active');
    nameReady = true;
  }
  nameOk.addEventListener('click', submitName);
  nameOk.addEventListener('touchend', e => { e.preventDefault(); submitName(); });
  nameInput.addEventListener('keydown', e => { if (e.key === 'Enter') submitName(); });

  // ============================================================
  // GAME STATE
  // ============================================================
  let gameState = 'title', worldX = 0, score = 0, frame = 0, hiScore = storedHi;
  let totalEnemiesSpawned = 0;
  let showLeaderboard = false; // toggled on game over/win after score is added

  // Fetch global leaderboard on page load (async, non-blocking)
  fetchGlobalLeaderboard();

  const player = {
    y: 380, hp: 3, maxHp: 3,
    attacking: false, atkTimer: 0,
    invTimer: 0, animFrame: 0, animTimer: 0,
  };

  let enemies = [], food = [], particles = [];
  let nextEnemy = 150, nextFood = 100;

  // ============================================================
  // INPUT - Keyboard
  // ============================================================
  const keys = {};
  document.addEventListener('keydown', e => {
    keys[e.key] = true;
    if ([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    if (e.key === ' ') {
      unlockAudio();
      if (gameState === 'title') { startGame(); return; }
      if (gameState === 'playing' && !player.attacking) {
        player.attacking = true;
        player.atkTimer = 20;
        playBark();
      }
    }
    if ((e.key === 'r' || e.key === 'R') && gameState !== 'playing' && gameState !== 'levelComplete') startGame();
  });
  document.addEventListener('keyup', e => { keys[e.key] = false; });

  // ============================================================
  // INPUT - Touch controls
  // ============================================================
  const touchKeys = { up: false, down: false };

  function setupTouchBtn(id, key) {
    const btn = document.getElementById(id);
    if (!btn) return;
    btn.addEventListener('touchstart', e => { e.preventDefault(); unlockAudio(); touchKeys[key] = true; btn.classList.add('pressed'); });
    btn.addEventListener('touchend', e => { e.preventDefault(); touchKeys[key] = false; btn.classList.remove('pressed'); });
    btn.addEventListener('touchcancel', e => { touchKeys[key] = false; btn.classList.remove('pressed'); });
  }
  setupTouchBtn('btn-up', 'up');
  setupTouchBtn('btn-down', 'down');

  const btnAttack = document.getElementById('btn-attack');
  if (btnAttack) {
    btnAttack.addEventListener('touchstart', e => {
      e.preventDefault();
      btnAttack.classList.add('pressed');
      unlockAudio();
      if (gameState === 'title') { startGame(); return; }
      if (gameState !== 'playing' && gameState !== 'levelComplete') { startGame(); return; }
      if (gameState === 'playing' && !player.attacking) {
        player.attacking = true;
        player.atkTimer = 20;
        playBark();
      }
    });
    btnAttack.addEventListener('touchend', e => { e.preventDefault(); btnAttack.classList.remove('pressed'); });
    btnAttack.addEventListener('touchcancel', e => { btnAttack.classList.remove('pressed'); });
  }

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    unlockAudio();
    if (gameState === 'title') { startGame(); return; }
    if (gameState !== 'playing' && gameState !== 'levelComplete') { startGame(); return; }
    if (!player.attacking) {
      player.attacking = true;
      player.atkTimer = 20;
      playBark();
    }
  });

  function startGame() {
    if (!nameReady) return;
    gameState = 'playing'; worldX = 0; score = 0; frame = 0;
    totalEnemiesSpawned = 0;
    currentLevel = 0;
    levelScenes = LEVELS[0];
    WORLD_END = levelScenes.length * SCENE_W;
    melodyNotes = melodyL1; bassNotes = bassL1;
    player.y = 380; player.hp = 3; player.maxHp = 3; player.attacking = false;
    player.atkTimer = 0; player.invTimer = 0;
    enemies = []; food = []; particles = [];
    nextEnemy = 150; nextFood = 100;
    showLeaderboard = false;
    levelCompleteTimer = 0;
    startMusic();
  }

  let levelCompleteTimer = 0;

  const LEVEL_MELODIES = [melodyL1, melodyL2, melodyL3];
  const LEVEL_BASSES = [bassL1, bassL2, bassL3];

  function startNextLevel() {
    currentLevel++;
    levelScenes = LEVELS[currentLevel];
    WORLD_END = levelScenes.length * SCENE_W;
    melodyNotes = LEVEL_MELODIES[currentLevel]; bassNotes = LEVEL_BASSES[currentLevel];
    worldX = 0; frame = 0;
    totalEnemiesSpawned = 0;
    enemies = []; food = []; particles = [];
    nextEnemy = 150; nextFood = 100;
    player.maxHp = 3 + currentLevel; player.hp = player.maxHp;
    player.attacking = false; player.atkTimer = 0; player.invTimer = 0;
    levelCompleteTimer = 0;
    gameState = 'playing';
    stopMusic();
    startMusic();
  }

  // ============================================================
  // SPAWN - randomized speeds, thugs every 10
  // ============================================================
  function spawnEnemy() {
    totalEnemiesSpawned++;
    const isL2 = currentLevel === 1;
    const isL3 = currentLevel === 2;
    const isRider = isL2 && totalEnemiesSpawned % 15 === 0;
    const isCat = isL2 && !isRider && Math.random() < 0.4;
    const isTram = isL3 && totalEnemiesSpawned % 12 === 0;
    const isUltra = isL3 && !isTram && Math.random() < 0.45;
    const isThug = !isRider && !isCat && !isTram && !isUltra && totalEnemiesSpawned % 10 === 0;

    let spd, hp, enemyType, variant, invincible = false;

    if (isTram) {
      enemyType = 'tram';
      variant = 'orange';
      spd = 2.5 + Math.random() * 1.5;
      hp = 9999; invincible = true;
    } else if (isUltra) {
      enemyType = 'ultra';
      variant = ULTRA_VARIANT_KEYS[Math.floor(Math.random() * ULTRA_VARIANT_KEYS.length)];
      spd = 0.2 + Math.random() * 0.5;
      hp = 2;
    } else if (isRider) {
      enemyType = 'rider';
      variant = RIDER_VARIANT_KEYS[Math.floor(Math.random() * RIDER_VARIANT_KEYS.length)];
      spd = 2.5 + Math.random() * 1.5;
      hp = 3;
    } else if (isCat) {
      enemyType = 'cat';
      variant = CAT_VARIANT_KEYS[Math.floor(Math.random() * CAT_VARIANT_KEYS.length)];
      spd = 0.5 + Math.random() * 2.0;
      hp = 1;
    } else if (isThug) {
      enemyType = 'dog';
      variant = DOG_VARIANT_KEYS[Math.floor(Math.random() * DOG_VARIANT_KEYS.length)];
      spd = 0.2 + Math.random() * 0.5;
      hp = 2;
    } else {
      enemyType = 'dog';
      variant = DOG_VARIANT_KEYS[Math.floor(Math.random() * DOG_VARIANT_KEYS.length)];
      spd = 0.3 + Math.random() * 1.2;
      hp = 1;
    }

    enemies.push({
      wx: worldX + W + 60,
      y: FLOOR_TOP + 20 + Math.random() * (FLOOR_BOT - FLOOR_TOP - 40),
      alive: true, af: 0, at: 0,
      spd: spd,
      hp: hp,
      maxHp: hp,
      isThug: isThug || isRider || isUltra || isTram,
      enemyType: enemyType,
      variant: variant,
      hitFlash: 0,
      invincible: invincible,
    });
    nextEnemy = worldX + 50 + Math.random() * 90;
  }

  function spawnFood() {
    const typesL1 = ['fishbone','wrapper','banana','can'];
    const typesL2 = ['fishbone','wrapper','xlb','firecracker','cabbage','xlb'];
    const typesL3 = ['fishbone','wrapper','pizza','gelato','spaghetti','pizza','gelato'];
    const allTypes = [typesL1, typesL2, typesL3];
    const types = allTypes[currentLevel] || typesL1;
    food.push({
      wx: worldX + W + 60,
      y: FLOOR_TOP + 20 + Math.random() * (FLOOR_BOT - FLOOR_TOP - 20),
      type: types[Math.floor(Math.random() * types.length)],
      collected: false,
    });
    nextFood = worldX + 70 + Math.random() * 90;
  }

  function particle(x, y, col, txt) {
    particles.push({ x, y, col, txt, life: 45, vy: -1.8, vx: 0 });
  }

  // ============================================================
  // SCENE DRAWINGS
  // ============================================================
  function sceneOffset(si) { return worldX - si * SCENE_W; }

  function bldg(x, y, w, h, wc, wn, dw) {
    if (x + w < -10 || x > W + 10) return;
    ctx.fillStyle = wc; ctx.fillRect(x, y, w, h);
    const cols = Math.floor((w - 8) / 12), rows = Math.floor((h - 10) / 14);
    for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
      ctx.fillStyle = Math.sin(frame * 0.015 + c * 5 + r * 7 + x * 0.1) > -0.2 ? wn : dw;
      ctx.fillRect(x + 4 + c * 12, y + 6 + r * 14, 6, 8);
    }
  }
  // HDB block helper - tall rectangular blocks with corridor lines
  function hdb(x, y, w, h, bodyColor) {
    if (x + w < -10 || x > W + 10) return;
    ctx.fillStyle = bodyColor; ctx.fillRect(x, y, w, h);
    // Windows - grid
    const cols = Math.floor((w - 6) / 10), rows = Math.floor((h - 8) / 12);
    for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
      ctx.fillStyle = Math.sin(frame * 0.01 + c * 3 + r * 5 + x * 0.2) > 0 ? '#ffd86e' : '#3a5a7a';
      ctx.fillRect(x + 4 + c * 10, y + 5 + r * 12, 6, 8);
    }
    // Corridor lines
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    for (let r = 0; r < rows; r++) ctx.fillRect(x, y + 4 + r * 12 + 9, w, 1);
  }
  function palm(x, gy) {
    if (x < -40 || x > W + 40) return;
    ctx.fillStyle = '#6b4226'; ctx.fillRect(x, gy - 50, 5, 50);
    for (let a = 0; a < 5; a++) {
      ctx.save(); ctx.translate(x + 2, gy - 50);
      ctx.rotate((a - 2) * 0.5 + Math.sin(frame * 0.02 + a) * 0.05);
      ctx.fillStyle = a % 2 ? '#3a9c3a' : '#2d8c2d';
      ctx.beginPath(); ctx.ellipse(0, -12, 4, 22, 0, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }
  }
  function lantern(x, y) {
    if (x < -20 || x > W + 20) return;
    const bob = Math.sin(frame * 0.04 + x * 0.1) * 2;
    ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x, y - 20); ctx.lineTo(x, y + bob); ctx.stroke();
    ctx.fillStyle = '#e83030';
    ctx.beginPath(); ctx.ellipse(x, y + 10 + bob, 8, 12, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#f5c040'; ctx.fillRect(x - 2, y - 2 + bob, 4, 4);
  }

  function drawSceneMBS(si) { const off = sceneOffset(si), bx = 500 - off * 0.5; for (let i = 0; i < 3; i++) bldg(bx + i * 80, FLOOR_TOP - 200, 50, 200, '#7088a0', '#aad4ff', '#4a5a6a'); ctx.fillStyle = '#8898a8'; ctx.fillRect(bx - 25, FLOOR_TOP - 210, 290, 16); ctx.fillStyle = '#4a9c4a'; ctx.fillRect(bx + 10, FLOOR_TOP - 218, 220, 10); ctx.fillStyle = 'rgba(100,200,255,0.4)'; ctx.fillRect(bx + 60, FLOOR_TOP - 216, 120, 6); palm(bx - 50, FLOOR_TOP); palm(bx + 280, FLOOR_TOP); ctx.fillStyle = 'rgba(41,128,185,0.15)'; ctx.fillRect(0, FLOOR_TOP - 5, W, 5); hdb(bx - 200, FLOOR_TOP - 130, 45, 130, '#b8a898'); hdb(bx + 350, FLOOR_TOP - 100, 40, 100, '#a0b0a0'); }
  function drawSceneMerlion(si) { const off = sceneOffset(si), mx = 400 - off * 0.5; ctx.fillStyle = '#999'; ctx.fillRect(mx + 20, FLOOR_TOP - 30, 60, 30); ctx.fillStyle = '#ccc'; ctx.fillRect(mx + 30, FLOOR_TOP - 100, 40, 75); ctx.fillStyle = '#ddd'; ctx.beginPath(); ctx.arc(mx + 50, FLOOR_TOP - 110, 24, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#5dade2'; ctx.lineWidth = 4; const sl = 35 + Math.sin(frame * 0.1) * 5; ctx.beginPath(); ctx.moveTo(mx + 74, FLOOR_TOP - 110); ctx.quadraticCurveTo(mx + 74 + sl, FLOOR_TOP - 120, mx + 74 + sl + 10, FLOOR_TOP - 70); ctx.stroke(); ctx.fillStyle = '#5dade2'; for (let i = 0; i < 4; i++) ctx.fillRect(mx + 74 + sl + 5 + i * 4, FLOOR_TOP - 65 + Math.sin(frame * 0.15 + i) * 6, 3, 3); ctx.fillStyle = 'rgba(41,128,185,0.2)'; ctx.fillRect(0, FLOOR_TOP - 5, W, 5); bldg(mx - 150, FLOOR_TOP - 120, 40, 120, '#607080', '#ffd86e', '#3a4a5a'); bldg(mx + 150, FLOOR_TOP - 90, 35, 90, '#708090', '#aad4ff', '#4a5a6a'); palm(mx - 80, FLOOR_TOP); palm(mx + 130, FLOOR_TOP); }
  // HDB HEARTLAND scene - dedicated HDB scene with multiple blocks
  function drawSceneHDB(si) {
    const off = sceneOffset(si), hx = 50 - off * 0.5;
    const hdbColors = ['#c8b8a0','#a8b8c8','#b8c0a8','#c0a8b0','#a0b0b8','#b8b0a0'];
    const heights = [220,180,250,200,160,230];
    for (let i = 0; i < 6; i++) {
      const sx = hx + i * 130;
      hdb(sx, FLOOR_TOP - heights[i], 80, heights[i], hdbColors[i]);
      // Void deck at bottom
      ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(sx + 5, FLOOR_TOP - 18, 70, 18);
      ctx.fillStyle = '#888'; ctx.fillRect(sx + 15, FLOOR_TOP - 16, 12, 14);
      ctx.fillRect(sx + 52, FLOOR_TOP - 16, 12, 14);
    }
    // Playground
    const px2 = hx + 300;
    if (px2 > -30 && px2 < W + 30) {
      ctx.fillStyle = '#d44'; ctx.fillRect(px2, FLOOR_TOP - 25, 4, 25);
      ctx.fillStyle = '#44d'; ctx.fillRect(px2 - 8, FLOOR_TOP - 28, 20, 4);
      ctx.fillStyle = '#4a4'; ctx.fillRect(px2 + 30, FLOOR_TOP - 15, 25, 3);
      ctx.fillStyle = '#888'; ctx.fillRect(px2 + 30, FLOOR_TOP - 15, 3, 15);
      ctx.fillRect(px2 + 52, FLOOR_TOP - 15, 3, 15);
    }
    palm(hx - 20, FLOOR_TOP); palm(hx + 750, FLOOR_TOP);
  }
  function drawSceneChinatown(si) { const off = sceneOffset(si), cx = 100 - off * 0.5; const colors = ['#e85050','#40a0e0','#e8c840','#50c878','#e08040','#c060c0','#5080e0']; for (let i = 0; i < 7; i++) { const sx = cx + i * 110; if (sx > W + 80 || sx + 80 < -80) continue; ctx.fillStyle = colors[i % colors.length]; ctx.fillRect(sx, FLOOR_TOP - 90, 80, 90); ctx.fillStyle = colors[(i+1) % colors.length]; ctx.fillRect(sx - 3, FLOOR_TOP - 96, 86, 8); ctx.fillStyle = '#f5f0e0'; ctx.fillRect(sx + 8, FLOOR_TOP - 70, 22, 20); ctx.fillRect(sx + 48, FLOOR_TOP - 70, 22, 20); ctx.fillStyle = '#5c3a1e'; ctx.fillRect(sx + 28, FLOOR_TOP - 40, 22, 40); ctx.fillStyle = '#f5f0e0'; ctx.fillRect(sx + 2, FLOOR_TOP - 40, 4, 40); ctx.fillRect(sx + 74, FLOOR_TOP - 40, 4, 40); } for (let i = 0; i < 10; i++) lantern(cx + 30 + i * 75, FLOOR_TOP - 110); }
  function drawSceneJooChiat(si) { const off = sceneOffset(si), jx = 80 - off * 0.5; const colors = ['#7ecfc0','#e8a0c0','#a0d0e8','#f0d080','#c0e0a0','#d0a0e0']; for (let i = 0; i < 7; i++) { const sx = jx + i * 105; if (sx > W + 80 || sx + 75 < -80) continue; ctx.fillStyle = colors[i % colors.length]; ctx.fillRect(sx, FLOOR_TOP - 80, 75, 80); ctx.fillStyle = colors[(i+2) % colors.length]; for (let t = 0; t < 6; t++) ctx.fillRect(sx + 5 + t * 12, FLOOR_TOP - 85, 8, 8); ctx.fillStyle = '#3a3a5a'; ctx.beginPath(); ctx.arc(sx + 20, FLOOR_TOP - 50, 10, Math.PI, 0); ctx.fillRect(sx + 10, FLOOR_TOP - 50, 20, 16); ctx.fill(); ctx.beginPath(); ctx.arc(sx + 55, FLOOR_TOP - 50, 10, Math.PI, 0); ctx.fillRect(sx + 45, FLOOR_TOP - 50, 20, 16); ctx.fill(); } }
  function drawSceneCBD(si) { const off = sceneOffset(si), bx = 50 - off * 0.4; const blds = [{x:0,w:50,h:250,c:'#506070'},{x:70,w:40,h:280,c:'#607080'},{x:130,w:55,h:220,c:'#5a6a7a'},{x:210,w:35,h:300,c:'#4a5a6a'},{x:260,w:60,h:260,c:'#6a7a8a'},{x:340,w:45,h:240,c:'#556575'},{x:400,w:50,h:290,c:'#5a6a80'},{x:470,w:38,h:230,c:'#607888'}]; for (const b of blds) bldg(bx + b.x, FLOOR_TOP - b.h, b.w, b.h, b.c, '#ffd86e', '#3a4a5a'); for (let i = 0; i < 4; i++) { const lx = bx + 30 + i * 150; if (lx < -10 || lx > W + 10) continue; ctx.fillStyle = '#555'; ctx.fillRect(lx, FLOOR_TOP - 50, 3, 50); ctx.fillStyle = '#ffd86e'; ctx.beginPath(); ctx.arc(lx + 1, FLOOR_TOP - 52, 5, 0, Math.PI * 2); ctx.fill(); } }
  function drawSceneHawker(si) { const off = sceneOffset(si), hx = 100 - off * 0.5; hdb(hx - 80, FLOOR_TOP - 160, 50, 160, '#b0a898'); ctx.fillStyle = '#8b4513'; ctx.fillRect(hx, FLOOR_TOP - 100, 500, 10); for (let i = 0; i < 6; i++) { ctx.fillStyle = '#aaa'; ctx.fillRect(hx + 20 + i * 90, FLOOR_TOP - 100, 6, 100); } const sc = ['#e85050','#40a0e0','#50c878','#e8c840','#e08040']; for (let i = 0; i < 5; i++) { const sx = hx + 10 + i * 95; if (sx > W + 80 || sx + 80 < -80) continue; ctx.fillStyle = sc[i]; ctx.fillRect(sx, FLOOR_TOP - 90, 80, 8); ctx.fillStyle = '#f5f0e0'; ctx.fillRect(sx + 5, FLOOR_TOP - 82, 70, 40); ctx.fillStyle = '#c0a050'; ctx.fillRect(sx + 10, FLOOR_TOP - 78, 15, 8); ctx.fillStyle = '#e85050'; ctx.fillRect(sx + 30, FLOOR_TOP - 78, 12, 8); } ctx.fillStyle = '#c00'; ctx.fillRect(hx + 180, FLOOR_TOP - 115, 120, 14); ctx.fillStyle = '#fff'; ctx.font = '10px monospace'; ctx.fillText('HAWKER CENTRE', hx + 190, FLOOR_TOP - 104); hdb(hx + 540, FLOOR_TOP - 140, 45, 140, '#a8b0a0'); }
  function drawSceneBotanic(si) { const off = sceneOffset(si), gx = 50 - off * 0.4; ctx.fillStyle = '#2d6b2d'; ctx.fillRect(0, FLOOR_TOP - 80, W, 80); for (let i = 0; i < 8; i++) { const tx = gx + i * 100; if (tx < -50 || tx > W + 50) continue; ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx + 12, FLOOR_TOP - 80 - (i % 3) * 20, 8, 80 + (i % 3) * 20); ctx.fillStyle = i % 2 ? '#3d8c3d' : '#2d7c2d'; ctx.beginPath(); ctx.arc(tx + 16, FLOOR_TOP - 100 - (i % 3) * 20, 25 + (i % 2) * 10, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#4a9c4a'; ctx.beginPath(); ctx.arc(tx + 8, FLOOR_TOP - 90 - (i % 3) * 20, 18, 0, Math.PI * 2); ctx.fill(); } const fc = ['#ff6b8a','#ff0','#ff8800','#ff55ff','#55aaff']; for (let i = 0; i < 12; i++) { const fx = gx + 20 + i * 65; if (fx < -10 || fx > W + 10) continue; ctx.fillStyle = fc[i % fc.length]; ctx.beginPath(); ctx.arc(fx, FLOOR_TOP - 5 - (i % 4) * 3, 4, 0, Math.PI * 2); ctx.fill(); } }
  function drawSceneHiking(si) { const off = sceneOffset(si), hx = -off * 0.3; ctx.fillStyle = '#3d7040'; ctx.beginPath(); ctx.moveTo(0, FLOOR_TOP); for (let i = 0; i <= W; i += 40) ctx.lineTo(i, FLOOR_TOP - 60 - Math.sin((i + hx) * 0.008) * 80 - Math.sin((i + hx) * 0.02) * 30); ctx.lineTo(W, FLOOR_TOP); ctx.fill(); ctx.fillStyle = '#2d5a30'; ctx.beginPath(); ctx.moveTo(0, FLOOR_TOP); for (let i = 0; i <= W; i += 30) ctx.lineTo(i, FLOOR_TOP - 30 - Math.sin((i + hx) * 0.012 + 1) * 50); ctx.lineTo(W, FLOOR_TOP); ctx.fill(); for (let i = 0; i < 10; i++) { const tx = hx + i * 90 + 30; if (tx < -30 || tx > W + 30) continue; const th = FLOOR_TOP - 40 - Math.sin((tx + off * 0.3) * 0.01) * 60; ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx, th, 4, FLOOR_TOP - th); ctx.fillStyle = '#2d6b2d'; ctx.beginPath(); ctx.arc(tx + 2, th - 8, 15, 0, Math.PI * 2); ctx.fill(); } }
  function drawSceneChangi(si) { const off = sceneOffset(si), cx = 80 - off * 0.5; ctx.fillStyle = '#c0d0e0'; ctx.fillRect(cx, FLOOR_TOP - 120, 600, 120); for (let i = 0; i < 15; i++) { ctx.fillStyle = i % 2 ? 'rgba(150,200,255,0.5)' : 'rgba(130,180,235,0.5)'; ctx.fillRect(cx + 10 + i * 38, FLOOR_TOP - 110, 30, 100); } ctx.fillStyle = '#aabbcc'; ctx.fillRect(cx + 500, FLOOR_TOP - 200, 25, 200); ctx.fillStyle = '#90a8c0'; ctx.fillRect(cx + 490, FLOOR_TOP - 210, 45, 15); ctx.fillStyle = '#2060a0'; ctx.fillRect(cx + 200, FLOOR_TOP - 130, 120, 16); ctx.fillStyle = '#fff'; ctx.font = 'bold 11px monospace'; ctx.fillText('CHANGI AIRPORT', cx + 208, FLOOR_TOP - 118); ctx.fillStyle = 'rgba(150,220,255,0.3)'; ctx.beginPath(); ctx.arc(cx + 300, FLOOR_TOP - 60, 80, Math.PI, 0); ctx.fill(); ctx.fillStyle = 'rgba(100,180,255,0.4)'; ctx.fillRect(cx + 297, FLOOR_TOP - 120, 6, 60 + Math.sin(frame * 0.1) * 3); }
  function drawSceneMall(si) { const off = sceneOffset(si), mx = 60 - off * 0.5; ctx.fillStyle = '#d0d0d0'; ctx.fillRect(mx, FLOOR_TOP - 160, 200, 160); ctx.fillStyle = 'rgba(150,200,255,0.4)'; ctx.fillRect(mx + 10, FLOOR_TOP - 150, 180, 140); ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.arc(mx + 100, FLOOR_TOP - 160, 100, Math.PI, 0); ctx.fill(); const sc = ['#e0c0a0','#c0a0d0','#a0d0c0','#d0a0a0']; for (let i = 0; i < 4; i++) { const sx = mx + 240 + i * 90; if (sx > W + 80 || sx < -80) continue; ctx.fillStyle = sc[i]; ctx.fillRect(sx, FLOOR_TOP - 80, 70, 80); ctx.fillStyle = '#333'; ctx.fillRect(sx + 15, FLOOR_TOP - 40, 40, 40); ctx.fillStyle = '#ffd86e'; ctx.fillRect(sx + 5, FLOOR_TOP - 85, 60, 8); } ctx.fillStyle = '#333'; ctx.fillRect(mx + 30, FLOOR_TOP - 130, 100, 14); ctx.fillStyle = '#f0c040'; ctx.font = 'bold 10px monospace'; ctx.fillText('ORCHARD RD', mx + 40, FLOOR_TOP - 119); }
  function drawSceneArtScience(si) { const off = sceneOffset(si), ax = 350 - off * 0.5; for (let i = 0; i < 7; i++) { ctx.save(); ctx.translate(ax + 60, FLOOR_TOP - 10); ctx.rotate((i - 3) * 0.22); ctx.fillStyle = i % 2 === 0 ? '#e8e0e0' : '#d8d0d0'; ctx.beginPath(); ctx.ellipse(0, -80, 16, 80, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } ctx.fillStyle = '#ccc'; ctx.fillRect(ax + 15, FLOOR_TOP - 20, 90, 20); ctx.fillStyle = 'rgba(93,173,226,0.3)'; ctx.fillRect(ax - 30, FLOOR_TOP - 3, 180, 5); bldg(ax + 250, FLOOR_TOP - 100, 25, 100, '#7088a0', '#aad4ff', '#4a5a6a'); palm(ax - 40, FLOOR_TOP); palm(ax + 180, FLOOR_TOP); hdb(ax - 160, FLOOR_TOP - 120, 50, 120, '#b8b0a8'); }
  function drawSceneEastCoast(si) { const off = sceneOffset(si), ex = -off * 0.3; ctx.fillStyle = '#2980b9'; ctx.fillRect(0, FLOOR_TOP - 50, W, 50); ctx.fillStyle = '#3498db'; for (let i = 0; i < W; i += 30) ctx.fillRect(i, FLOOR_TOP - 50 + Math.sin(frame * 0.05 + i * 0.05) * 3, 20, 3); ctx.fillStyle = '#f0dca0'; ctx.fillRect(0, FLOOR_TOP - 5, W, 8); for (let i = 0; i < 3; i++) { const bx = ex + 100 + i * 250; if (bx < -30 || bx > W + 30) continue; ctx.fillStyle = '#888'; ctx.fillRect(bx, FLOOR_TOP - 20, 30, 5); ctx.fillRect(bx + 5, FLOOR_TOP - 15, 3, 15); ctx.fillRect(bx + 22, FLOOR_TOP - 15, 3, 15); ctx.fillStyle = 'rgba(150,150,150,0.3)'; for (let s = 0; s < 3; s++) { ctx.beginPath(); ctx.arc(bx + 15 + Math.sin(frame * 0.08 + s) * 5, FLOOR_TOP - 25 - s * 8, 4, 0, Math.PI * 2); ctx.fill(); } } palm(ex + 50, FLOOR_TOP); palm(ex + 400, FLOOR_TOP); palm(ex + 600, FLOOR_TOP); ctx.fillStyle = '#c85050'; ctx.fillRect(0, FLOOR_TOP - 2, W, 3); hdb(ex + 700, FLOOR_TOP - 150, 55, 150, '#a8a0b0'); }

  // ============================================================
  // SHANGHAI SCENE HELPERS
  // ============================================================
  function artDeco(x, y, w, h) {
    if (x + w < -10 || x > W + 10) return;
    ctx.fillStyle = '#d4c8a8'; ctx.fillRect(x, y, w, h);
    // Art deco top ornament
    ctx.fillStyle = '#c0b090'; ctx.fillRect(x - 3, y - 6, w + 6, 8);
    ctx.fillStyle = '#b0a080'; ctx.fillRect(x + w/2 - 4, y - 14, 8, 10);
    // Windows with arched tops
    const cols = Math.floor((w - 8) / 14);
    for (let c = 0; c < cols; c++) {
      const wx = x + 6 + c * 14;
      ctx.fillStyle = '#3a4a5a'; ctx.fillRect(wx, y + 12, 8, 16);
      ctx.beginPath(); ctx.arc(wx + 4, y + 12, 4, Math.PI, 0); ctx.fill();
    }
    // Horizontal bands
    ctx.fillStyle = '#c0b090';
    ctx.fillRect(x, y + Math.floor(h * 0.4), w, 3);
    ctx.fillRect(x, y + Math.floor(h * 0.7), w, 3);
  }

  function shikumen(x, y, w) {
    if (x + w < -10 || x > W + 10) return;
    const h = 75;
    ctx.fillStyle = '#8c7a6a'; ctx.fillRect(x, y - h, w, h);
    // Stone door frame
    ctx.fillStyle = '#a09080'; ctx.fillRect(x + w/2 - 10, y - h + 20, 20, h - 20);
    ctx.fillStyle = '#5c4a3a'; ctx.fillRect(x + w/2 - 7, y - h + 25, 14, h - 25);
    // Circular top
    ctx.fillStyle = '#a09080'; ctx.beginPath(); ctx.arc(x + w/2, y - h + 22, 12, Math.PI, 0); ctx.fill();
    // Windows
    ctx.fillStyle = '#4a3a2a';
    ctx.fillRect(x + 4, y - h + 15, 8, 10);
    ctx.fillRect(x + w - 12, y - h + 15, 8, 10);
  }

  function neonSign(x, y, text, color) {
    if (x < -80 || x > W + 80) return;
    const flicker = Math.sin(frame * 0.15 + x * 0.3) > -0.3;
    if (!flicker) return;
    ctx.fillStyle = color;
    ctx.font = 'bold 12px monospace';
    ctx.fillText(text, x, y);
    // Glow
    ctx.save(); ctx.globalAlpha = 0.3;
    ctx.fillStyle = color;
    ctx.fillRect(x - 2, y - 12, text.length * 8, 16);
    ctx.restore();
  }

  function pagoda(x, y, tiers) {
    if (x < -60 || x > W + 60) return;
    for (let t = 0; t < tiers; t++) {
      const tw = 50 - t * 8, th = 18;
      const tx = x - tw / 2, ty = y - t * (th + 4);
      ctx.fillStyle = t % 2 ? '#c83030' : '#d44040';
      ctx.fillRect(tx, ty - th, tw, th);
      // Eaves
      ctx.fillStyle = '#8b4513';
      ctx.beginPath();
      ctx.moveTo(tx - 8, ty); ctx.lineTo(tx + tw + 8, ty);
      ctx.lineTo(tx + tw + 3, ty - 4); ctx.lineTo(tx - 3, ty - 4);
      ctx.fill();
      // Curved eave tips
      ctx.beginPath(); ctx.arc(tx - 6, ty - 2, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(tx + tw + 6, ty - 2, 3, 0, Math.PI * 2); ctx.fill();
    }
    // Spire
    ctx.fillStyle = '#f0c040';
    ctx.fillRect(x - 1, y - tiers * 22 - 15, 2, 15);
    ctx.beginPath(); ctx.arc(x, y - tiers * 22 - 15, 3, 0, Math.PI * 2); ctx.fill();
  }

  function overpass(x, w, gy) {
    if (x + w < -10 || x > W + 10) return;
    ctx.fillStyle = '#808080'; ctx.fillRect(x, gy - 60, w, 8);
    ctx.fillStyle = '#666'; ctx.fillRect(x, gy - 52, 6, 52);
    ctx.fillRect(x + w - 6, gy - 52, 6, 52);
    // Railing
    ctx.fillStyle = '#999';
    for (let i = 0; i < w; i += 12) ctx.fillRect(x + i, gy - 66, 2, 8);
    ctx.fillRect(x, gy - 66, w, 2);
  }

  // ============================================================
  // SHANGHAI SCENES
  // ============================================================
  function drawSceneBund(si) {
    const off = sceneOffset(si), bx = 40 - off * 0.5;
    // Row of art deco buildings along the Bund
    const heights = [140, 160, 120, 180, 130, 150, 170, 140];
    const widths = [65, 55, 70, 50, 60, 55, 65, 60];
    for (let i = 0; i < 8; i++) {
      artDeco(bx + i * 80, FLOOR_TOP - heights[i], widths[i], heights[i]);
    }
    // Huangpu river hint
    ctx.fillStyle = 'rgba(41,100,160,0.25)'; ctx.fillRect(0, FLOOR_TOP - 5, W, 5);
    neonSign(bx + 100, FLOOR_TOP - 190, 'THE BUND', '#ff6040');
  }

  function drawScenePudong(si) {
    const off = sceneOffset(si), px2 = 200 - off * 0.4;
    // Oriental Pearl Tower
    const opx = px2 + 100;
    ctx.fillStyle = '#c060a0'; ctx.fillRect(opx - 3, FLOOR_TOP - 280, 6, 280);
    ctx.fillStyle = '#e070b0'; ctx.beginPath(); ctx.arc(opx, FLOOR_TOP - 200, 18, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#d060a0'; ctx.beginPath(); ctx.arc(opx, FLOOR_TOP - 130, 12, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#e070b0'; ctx.beginPath(); ctx.arc(opx, FLOOR_TOP - 250, 8, 0, Math.PI * 2); ctx.fill();
    // Shanghai Tower (tallest)
    const stx = px2 + 250;
    ctx.fillStyle = '#6080a0'; ctx.fillRect(stx - 12, FLOOR_TOP - 310, 24, 310);
    ctx.fillStyle = '#7090b0';
    for (let r = 0; r < 20; r++) ctx.fillRect(stx - 10, FLOOR_TOP - 300 + r * 15, 20, 8);
    ctx.fillStyle = '#90a8c0'; ctx.fillRect(stx - 2, FLOOR_TOP - 320, 4, 15);
    // Bottle Opener (SWFC)
    const box = px2 + 370;
    ctx.fillStyle = '#5a6a7a'; ctx.fillRect(box - 15, FLOOR_TOP - 260, 30, 260);
    // Trapezoid opening at top
    ctx.fillStyle = '#0a0a2e';
    ctx.beginPath(); ctx.moveTo(box - 8, FLOOR_TOP - 250); ctx.lineTo(box + 8, FLOOR_TOP - 250);
    ctx.lineTo(box + 5, FLOOR_TOP - 225); ctx.lineTo(box - 5, FLOOR_TOP - 225); ctx.fill();
    ctx.fillStyle = '#7088a0';
    for (let r = 0; r < 15; r++) ctx.fillRect(box - 13, FLOOR_TOP - 210 + r * 14, 26, 6);
    // Jin Mao Tower
    bldg(px2 + 450, FLOOR_TOP - 230, 35, 230, '#708090', '#ffd86e', '#4a5a6a');
    // Other skyscrapers
    bldg(px2, FLOOR_TOP - 180, 45, 180, '#607080', '#aad4ff', '#3a5a6a');
    bldg(px2 + 520, FLOOR_TOP - 160, 40, 160, '#506070', '#ffd86e', '#3a4a5a');
  }

  function drawSceneFrenchConcession(si) {
    const off = sceneOffset(si), fx = 60 - off * 0.5;
    // Plane trees lining the street
    for (let i = 0; i < 8; i++) {
      const tx = fx + i * 95;
      if (tx < -50 || tx > W + 50) continue;
      ctx.fillStyle = '#5c4a3a'; ctx.fillRect(tx + 10, FLOOR_TOP - 70, 6, 70);
      ctx.fillStyle = '#4a8c4a'; ctx.beginPath(); ctx.arc(tx + 13, FLOOR_TOP - 85, 28, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#3d7c3d'; ctx.beginPath(); ctx.arc(tx + 5, FLOOR_TOP - 75, 20, 0, Math.PI * 2); ctx.fill();
    }
    // Old lane houses
    const colors = ['#e8dcc8','#d8c8a8','#c8b898','#d0c0a0','#e0d0b8'];
    for (let i = 0; i < 6; i++) {
      shikumen(fx + 30 + i * 120, FLOOR_TOP, 70);
    }
    neonSign(fx + 200, FLOOR_TOP - 100, 'FRENCH CONCESSION', '#50c878');
  }

  function drawSceneYuyuan(si) {
    const off = sceneOffset(si), yx = 100 - off * 0.5;
    // Garden wall
    ctx.fillStyle = '#f0e8d0'; ctx.fillRect(yx - 20, FLOOR_TOP - 50, 800, 50);
    ctx.fillStyle = '#888'; ctx.fillRect(yx - 20, FLOOR_TOP - 56, 800, 8);
    // Zigzag bridge
    ctx.fillStyle = '#c0b090';
    for (let i = 0; i < 6; i++) {
      const bx = yx + 60 + i * 50;
      ctx.fillRect(bx, FLOOR_TOP - 15, 40, 6);
      ctx.fillStyle = '#a09070'; ctx.fillRect(bx + 15, FLOOR_TOP - 15, 3, 15); ctx.fillStyle = '#c0b090';
    }
    // Pond
    ctx.fillStyle = 'rgba(80,150,100,0.3)'; ctx.fillRect(yx + 50, FLOOR_TOP - 8, 320, 8);
    // Pagoda
    pagoda(yx + 500, FLOOR_TOP, 4);
    // Rocks
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.arc(yx + 420, FLOOR_TOP - 15, 20, Math.PI, 0); ctx.fill();
    ctx.fillStyle = '#777';
    ctx.beginPath(); ctx.arc(yx + 440, FLOOR_TOP - 10, 15, Math.PI, 0); ctx.fill();
    // Lanterns
    for (let i = 0; i < 8; i++) lantern(yx + 50 + i * 70, FLOOR_TOP - 60);
    neonSign(yx + 200, FLOOR_TOP - 75, 'YUYUAN GARDEN', '#e83030');
  }

  function drawSceneNanjingRd(si) {
    const off = sceneOffset(si), nx = 40 - off * 0.5;
    // Buildings on both sides with lots of neon
    const colors = ['#d8c8b0','#c0b0a0','#b8a890','#c8b8a0','#d0c0a8','#c0a890'];
    for (let i = 0; i < 7; i++) {
      const sx = nx + i * 100;
      if (sx > W + 80 || sx + 70 < -80) continue;
      ctx.fillStyle = colors[i % colors.length];
      ctx.fillRect(sx, FLOOR_TOP - 100, 70, 100);
      // Shop fronts
      ctx.fillStyle = '#5c3a1e'; ctx.fillRect(sx + 15, FLOOR_TOP - 45, 40, 45);
      ctx.fillStyle = '#ffd86e'; ctx.fillRect(sx + 17, FLOOR_TOP - 43, 36, 30);
    }
    // Pedestrian street markings
    ctx.fillStyle = '#d0c0a0'; ctx.fillRect(nx, FLOOR_TOP - 3, 700, 3);
    // Neon signs everywhere
    const neonColors = ['#ff4040','#40ff40','#4080ff','#ff40ff','#ffff40','#40ffff'];
    for (let i = 0; i < 10; i++) {
      neonSign(nx + 20 + i * 70, FLOOR_TOP - 110 - (i % 3) * 15, 'ÂïÜ', neonColors[i % neonColors.length]);
    }
    neonSign(nx + 150, FLOOR_TOP - 130, 'NANJING RD', '#ff6040');
  }

  function drawScenePeoplesSq(si) {
    const off = sceneOffset(si), px2 = 80 - off * 0.5;
    // Open square with museum building
    ctx.fillStyle = '#c0b8a8'; ctx.fillRect(px2 + 150, FLOOR_TOP - 80, 300, 80);
    // Museum roof tiers
    ctx.fillStyle = '#a09888';
    ctx.fillRect(px2 + 180, FLOOR_TOP - 100, 240, 22);
    ctx.fillRect(px2 + 210, FLOOR_TOP - 115, 180, 18);
    ctx.fillRect(px2 + 250, FLOOR_TOP - 125, 100, 14);
    // Columns
    for (let i = 0; i < 8; i++) {
      ctx.fillStyle = '#b0a898'; ctx.fillRect(px2 + 165 + i * 35, FLOOR_TOP - 78, 6, 78);
    }
    // Square floor pattern
    ctx.fillStyle = '#999'; for (let i = 0; i < 12; i++) ctx.fillRect(px2 + 50 + i * 45, FLOOR_TOP - 2, 30, 2);
    // Trees in square
    for (let i = 0; i < 4; i++) {
      const tx = px2 + 40 + i * 140;
      ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx, FLOOR_TOP - 40, 4, 40);
      ctx.fillStyle = '#3d8c3d'; ctx.beginPath(); ctx.arc(tx + 2, FLOOR_TOP - 48, 16, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawSceneXintiandi(si) {
    const off = sceneOffset(si), xx = 50 - off * 0.5;
    // Shikumen style buildings mixed with modern
    for (let i = 0; i < 5; i++) shikumen(xx + i * 140, FLOOR_TOP, 80);
    // Modern glass additions between
    for (let i = 0; i < 4; i++) {
      const gx = xx + 90 + i * 140;
      ctx.fillStyle = 'rgba(150,200,255,0.3)'; ctx.fillRect(gx, FLOOR_TOP - 65, 40, 65);
      ctx.fillStyle = 'rgba(130,180,235,0.4)';
      for (let r = 0; r < 4; r++) ctx.fillRect(gx + 2, FLOOR_TOP - 60 + r * 15, 36, 10);
    }
    // Cafe tables outside
    for (let i = 0; i < 6; i++) {
      const tx = xx + 30 + i * 100;
      if (tx < -20 || tx > W + 20) continue;
      ctx.fillStyle = '#8b6914'; ctx.fillRect(tx, FLOOR_TOP - 8, 2, 8);
      ctx.fillStyle = '#c0a050'; ctx.fillRect(tx - 6, FLOOR_TOP - 10, 14, 3);
    }
    neonSign(xx + 250, FLOOR_TOP - 90, 'XINTIANDI', '#f0c040');
  }

  function drawSceneJingan(si) {
    const off = sceneOffset(si), jx = 200 - off * 0.5;
    // Temple building
    ctx.fillStyle = '#c8a840'; ctx.fillRect(jx - 30, FLOOR_TOP - 100, 250, 100);
    // Multi-tiered roof
    for (let t = 0; t < 3; t++) {
      const rw = 270 - t * 40, rx = jx - 40 + t * 20;
      ctx.fillStyle = '#8b6914';
      ctx.beginPath(); ctx.moveTo(rx, FLOOR_TOP - 100 - t * 30);
      ctx.lineTo(rx + rw, FLOOR_TOP - 100 - t * 30);
      ctx.lineTo(rx + rw - 15, FLOOR_TOP - 115 - t * 30);
      ctx.lineTo(rx + 15, FLOOR_TOP - 115 - t * 30); ctx.fill();
      // Curved eave tips
      ctx.beginPath(); ctx.arc(rx + 5, FLOOR_TOP - 100 - t * 30, 4, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(rx + rw - 5, FLOOR_TOP - 100 - t * 30, 4, 0, Math.PI * 2); ctx.fill();
    }
    // Pillars
    for (let i = 0; i < 6; i++) { ctx.fillStyle = '#c03030'; ctx.fillRect(jx - 15 + i * 42, FLOOR_TOP - 98, 8, 98); }
    // Modern skyscrapers behind
    bldg(jx - 150, FLOOR_TOP - 200, 40, 200, '#506070', '#ffd86e', '#3a4a5a');
    bldg(jx + 280, FLOOR_TOP - 250, 50, 250, '#607080', '#aad4ff', '#4a5a6a');
  }

  function drawSceneHuaihai(si) {
    const off = sceneOffset(si), hx = 50 - off * 0.5;
    // IAPM Mall
    ctx.fillStyle = '#e0d0d0'; ctx.fillRect(hx + 100, FLOOR_TOP - 140, 200, 140);
    ctx.fillStyle = 'rgba(150,200,255,0.5)';
    for (let r = 0; r < 8; r++) ctx.fillRect(hx + 105, FLOOR_TOP - 135 + r * 17, 190, 12);
    ctx.fillStyle = '#333'; ctx.fillRect(hx + 150, FLOOR_TOP - 150, 100, 14);
    ctx.fillStyle = '#f0c040'; ctx.font = 'bold 10px monospace'; ctx.fillText('iapm', hx + 175, FLOOR_TOP - 139);
    // Other shops
    const shopColors = ['#c0a0d0','#a0d0c0','#d0a0a0','#a0c0d0'];
    for (let i = 0; i < 4; i++) {
      const sx = hx + 350 + i * 85;
      if (sx > W + 80 || sx < -80) continue;
      ctx.fillStyle = shopColors[i]; ctx.fillRect(sx, FLOOR_TOP - 80, 65, 80);
      ctx.fillStyle = '#333'; ctx.fillRect(sx + 10, FLOOR_TOP - 40, 45, 40);
      ctx.fillStyle = '#ffd86e'; ctx.fillRect(sx + 12, FLOOR_TOP - 38, 41, 28);
    }
    // Plane trees
    for (let i = 0; i < 5; i++) {
      const tx = hx + i * 150;
      if (tx < -30 || tx > W + 30) continue;
      ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx, FLOOR_TOP - 55, 5, 55);
      ctx.fillStyle = '#4a8c4a'; ctx.beginPath(); ctx.arc(tx + 3, FLOOR_TOP - 65, 22, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawSceneXujiahui(si) {
    const off = sceneOffset(si), xx = 80 - off * 0.5;
    // Xujiahui Cathedral
    const cx2 = xx + 200;
    ctx.fillStyle = '#c0a080'; ctx.fillRect(cx2 - 50, FLOOR_TOP - 120, 100, 120);
    // Two towers
    ctx.fillStyle = '#b09070'; ctx.fillRect(cx2 - 55, FLOOR_TOP - 160, 25, 50);
    ctx.fillRect(cx2 + 30, FLOOR_TOP - 160, 25, 50);
    // Pointed spires
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.moveTo(cx2 - 55, FLOOR_TOP - 160); ctx.lineTo(cx2 - 42, FLOOR_TOP - 195);
    ctx.lineTo(cx2 - 30, FLOOR_TOP - 160); ctx.fill();
    ctx.beginPath(); ctx.moveTo(cx2 + 30, FLOOR_TOP - 160); ctx.lineTo(cx2 + 43, FLOOR_TOP - 195);
    ctx.lineTo(cx2 + 55, FLOOR_TOP - 160); ctx.fill();
    // Rose window
    ctx.fillStyle = '#4a6a9a'; ctx.beginPath(); ctx.arc(cx2, FLOOR_TOP - 90, 15, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#5a7aaa'; ctx.beginPath(); ctx.arc(cx2, FLOOR_TOP - 90, 10, 0, Math.PI * 2); ctx.fill();
    // Door
    ctx.fillStyle = '#5c3a1e'; ctx.fillRect(cx2 - 12, FLOOR_TOP - 50, 24, 50);
    ctx.beginPath(); ctx.arc(cx2, FLOOR_TOP - 50, 12, Math.PI, 0); ctx.fill();
    // SJTU campus hint
    bldg(xx, FLOOR_TOP - 100, 60, 100, '#a0b0a0', '#ffd86e', '#4a5a4a');
    // Modern buildings
    bldg(xx + 400, FLOOR_TOP - 200, 50, 200, '#607080', '#aad4ff', '#3a5a6a');
    bldg(xx + 480, FLOOR_TOP - 170, 40, 170, '#506070', '#ffd86e', '#3a4a5a');
  }

  function drawSceneSuzhouCreek(si) {
    const off = sceneOffset(si), sx2 = 50 - off * 0.5;
    // Water
    ctx.fillStyle = '#2980b9'; ctx.fillRect(0, FLOOR_TOP - 40, W, 40);
    ctx.fillStyle = '#3498db';
    for (let i = 0; i < W; i += 25) ctx.fillRect(i, FLOOR_TOP - 40 + Math.sin(frame * 0.06 + i * 0.04) * 3, 16, 2);
    // Post Office building
    const pox = sx2 + 200;
    ctx.fillStyle = '#c8b898'; ctx.fillRect(pox, FLOOR_TOP - 130, 180, 130);
    ctx.fillStyle = '#b0a080';
    ctx.fillRect(pox - 5, FLOOR_TOP - 136, 190, 8);
    // Clock tower
    ctx.fillStyle = '#b8a888'; ctx.fillRect(pox + 70, FLOOR_TOP - 170, 40, 40);
    ctx.fillStyle = '#f0e8d0'; ctx.beginPath(); ctx.arc(pox + 90, FLOOR_TOP - 155, 12, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#333'; ctx.fillRect(pox + 89, FLOOR_TOP - 163, 2, 10);
    ctx.fillRect(pox + 88, FLOOR_TOP - 155, 6, 2);
    // Columns
    for (let i = 0; i < 5; i++) ctx.fillRect(pox + 15 + i * 35, FLOOR_TOP - 128, 6, 128);
    // Bridge
    ctx.fillStyle = '#888'; ctx.fillRect(sx2 + 50, FLOOR_TOP - 50, 120, 10);
    ctx.fillStyle = '#777'; ctx.fillRect(sx2 + 55, FLOOR_TOP - 50, 4, 50); ctx.fillRect(sx2 + 162, FLOOR_TOP - 50, 4, 50);
    // Warehouses
    artDeco(sx2 + 450, FLOOR_TOP - 90, 80, 90);
    artDeco(sx2 + 550, FLOOR_TOP - 70, 60, 70);
  }

  function drawSceneSHTower(si) {
    const off = sceneOffset(si), tx = 300 - off * 0.4;
    // Shanghai Tower (twisted)
    ctx.fillStyle = '#7090b0';
    ctx.beginPath(); ctx.moveTo(tx - 18, FLOOR_TOP); ctx.lineTo(tx - 14, FLOOR_TOP - 310);
    ctx.lineTo(tx + 14, FLOOR_TOP - 310); ctx.lineTo(tx + 18, FLOOR_TOP); ctx.fill();
    // Twist pattern
    for (let i = 0; i < 20; i++) {
      const yy = FLOOR_TOP - i * 15;
      const tw = Math.sin(i * 0.3) * 3;
      ctx.fillStyle = i % 2 ? '#80a0c0' : '#6888a8';
      ctx.fillRect(tx - 12 + tw, yy - 12, 24, 8);
    }
    ctx.fillStyle = '#90a8c0'; ctx.fillRect(tx - 2, FLOOR_TOP - 325, 4, 18);
    // SWFC (bottle opener)
    const bx = tx + 120;
    ctx.fillStyle = '#5a6a7a'; ctx.fillRect(bx - 15, FLOOR_TOP - 260, 30, 260);
    ctx.fillStyle = '#0a0a2e';
    ctx.beginPath(); ctx.moveTo(bx - 8, FLOOR_TOP - 250); ctx.lineTo(bx + 8, FLOOR_TOP - 250);
    ctx.lineTo(bx + 5, FLOOR_TOP - 230); ctx.lineTo(bx - 5, FLOOR_TOP - 230); ctx.fill();
    // Jin Mao
    bldg(tx - 120, FLOOR_TOP - 230, 35, 230, '#708090', '#ffd86e', '#4a5a6a');
    // Other
    bldg(tx + 200, FLOOR_TOP - 180, 45, 180, '#607080', '#aad4ff', '#3a5a6a');
    bldg(tx - 200, FLOOR_TOP - 150, 40, 150, '#506070', '#ffd86e', '#3a4a5a');
  }

  function drawSceneGubei(si) {
    const off = sceneOffset(si), gx = 50 - off * 0.5;
    // Modern residential towers
    const towerColors = ['#a8b8c8','#b8c0a8','#c0a8b0','#a0b0b8','#b0a8b8','#a8c0b8'];
    const heights = [200,170,220,180,210,190];
    for (let i = 0; i < 6; i++) {
      const bx = gx + i * 110;
      if (bx > W + 60 || bx + 50 < -60) continue;
      hdb(bx, FLOOR_TOP - heights[i], 60, heights[i], towerColors[i]);
    }
    // Overpass
    overpass(gx + 100, 400, FLOOR_TOP);
    // Trees between buildings
    for (let i = 0; i < 8; i++) {
      const tx = gx + 20 + i * 85;
      if (tx < -20 || tx > W + 20) continue;
      ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx, FLOOR_TOP - 35, 4, 35);
      ctx.fillStyle = '#3d8c3d'; ctx.beginPath(); ctx.arc(tx + 2, FLOOR_TOP - 42, 14, 0, Math.PI * 2); ctx.fill();
    }
    neonSign(gx + 250, FLOOR_TOP - 230, 'GUBEI', '#40ffff');
  }

  // ============================================================
  // MILAN SKY
  // ============================================================
  function drawSkyMilan() {
    const grad = ctx.createLinearGradient(0, 0, 0, FLOOR_TOP);
    grad.addColorStop(0, '#1a2a4e'); grad.addColorStop(0.25, '#2a3a6e');
    grad.addColorStop(0.55, '#6080b8'); grad.addColorStop(1, '#c8a8d0');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, W, FLOOR_TOP + 5);
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    for (let i = 0; i < 20; i++) { const sx = (53 * (i+1) * 9) % W, sy = (53 * (i+1) * 5) % 60; if (Math.sin(frame * 0.035 + i * 2) > 0.4) ctx.fillRect(sx, sy, 2, 2); }
    // Subtle Olympic rings in sky
    drawOlympicRings(W - 110, 25, 8, 0.15);
  }

  // ============================================================
  // OLYMPIC HELPERS
  // ============================================================
  function drawOlympicRings(x, y, r, alpha) {
    ctx.save(); ctx.globalAlpha = alpha; ctx.lineWidth = 2;
    const cols = ['#0081C8','#000','#EE334E','#FCB131','#00A651'];
    const offsets = [0, r*2.2, r*4.4, r*1.1, r*3.3];
    const rows = [0,0,0,r*1.1,r*1.1];
    for (let i = 0; i < 5; i++) {
      ctx.strokeStyle = cols[i]; ctx.beginPath();
      ctx.arc(x + offsets[i], y + rows[i], r, 0, Math.PI * 2); ctx.stroke();
    }
    ctx.restore();
  }

  function olympicBooth(x, gy) {
    if (x < -40 || x > W + 40) return;
    ctx.fillStyle = '#0081C8'; ctx.fillRect(x, gy - 35, 40, 35);
    ctx.fillStyle = '#fff'; ctx.fillRect(x + 2, gy - 33, 36, 18);
    drawOlympicRings(x + 10, gy - 23, 4, 0.8);
    ctx.fillStyle = '#FCB131'; ctx.fillRect(x - 3, gy - 38, 46, 5);
    // Flag
    ctx.fillStyle = '#00A651'; ctx.fillRect(x + 15, gy - 52, 2, 16);
    ctx.fillStyle = '#fff'; ctx.fillRect(x + 17, gy - 52, 12, 8);
    drawOlympicRings(x + 19, gy - 48, 2, 0.9);
  }

  // ============================================================
  // MILAN SCENES
  // ============================================================
  function drawSceneDuomo(si) {
    const off = sceneOffset(si), dx = 200 - off * 0.5;
    // Main cathedral body
    ctx.fillStyle = '#e0d8d0'; ctx.fillRect(dx - 60, FLOOR_TOP - 140, 300, 140);
    // Gothic spires
    for (let i = 0; i < 9; i++) {
      const sx = dx - 40 + i * 35;
      const sh = 50 + Math.sin(i * 0.7) * 30 + (i === 4 ? 60 : 0);
      ctx.fillStyle = '#d8d0c8'; ctx.fillRect(sx, FLOOR_TOP - 140 - sh, 6, sh);
      ctx.fillStyle = '#c8c0b8';
      ctx.beginPath(); ctx.moveTo(sx - 1, FLOOR_TOP - 140 - sh);
      ctx.lineTo(sx + 3, FLOOR_TOP - 140 - sh - 15);
      ctx.lineTo(sx + 7, FLOOR_TOP - 140 - sh); ctx.fill();
    }
    // Main spire with Madonnina
    ctx.fillStyle = '#f0c040'; ctx.fillRect(dx + 108, FLOOR_TOP - 260, 3, 10);
    ctx.beginPath(); ctx.arc(dx + 110, FLOOR_TOP - 262, 4, 0, Math.PI * 2); ctx.fill();
    // Rose window
    ctx.fillStyle = '#6080b0'; ctx.beginPath(); ctx.arc(dx + 80, FLOOR_TOP - 100, 18, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#8ca8d0'; ctx.beginPath(); ctx.arc(dx + 80, FLOOR_TOP - 100, 12, 0, Math.PI * 2); ctx.fill();
    // Gothic arched doors
    for (let i = 0; i < 5; i++) {
      const ddx = dx + 10 + i * 50;
      ctx.fillStyle = '#5c4a3a'; ctx.fillRect(ddx, FLOOR_TOP - 50, 20, 50);
      ctx.beginPath(); ctx.arc(ddx + 10, FLOOR_TOP - 50, 10, Math.PI, 0); ctx.fill();
    }
    // Gothic windows (rows)
    for (let r = 0; r < 3; r++) for (let c = 0; c < 8; c++) {
      ctx.fillStyle = '#8898a8'; ctx.fillRect(dx - 45 + c * 35, FLOOR_TOP - 130 + r * 25, 8, 14);
    }
    olympicBooth(dx - 100, FLOOR_TOP);
  }

  function drawSceneGalleria(si) {
    const off = sceneOffset(si), gx = 150 - off * 0.5;
    // Grand building facade
    ctx.fillStyle = '#d8d0c0'; ctx.fillRect(gx, FLOOR_TOP - 130, 350, 130);
    // Triumphal arch entrance
    ctx.fillStyle = '#c0b8a8';
    ctx.beginPath(); ctx.arc(gx + 175, FLOOR_TOP - 80, 50, Math.PI, 0); ctx.fill();
    ctx.fillRect(gx + 125, FLOOR_TOP - 80, 100, 80);
    ctx.fillStyle = '#4a3a2a'; ctx.fillRect(gx + 140, FLOOR_TOP - 70, 70, 70);
    // Glass dome top
    ctx.fillStyle = 'rgba(150,200,255,0.4)';
    ctx.beginPath(); ctx.arc(gx + 175, FLOOR_TOP - 130, 40, Math.PI, 0); ctx.fill();
    // Iron cross pattern on dome
    ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(gx + 155, FLOOR_TOP - 130); ctx.lineTo(gx + 195, FLOOR_TOP - 130); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(gx + 175, FLOOR_TOP - 170); ctx.lineTo(gx + 175, FLOOR_TOP - 130); ctx.stroke();
    // Side windows
    for (let i = 0; i < 4; i++) {
      ctx.fillStyle = '#8898a8'; ctx.fillRect(gx + 15 + i * 30, FLOOR_TOP - 110, 12, 22);
      ctx.fillRect(gx + 240 + i * 30, FLOOR_TOP - 110, 12, 22);
    }
    // Statues on top
    for (let i = 0; i < 5; i++) {
      ctx.fillStyle = '#b8b0a0'; ctx.fillRect(gx + 50 + i * 65, FLOOR_TOP - 140, 6, 12);
    }
    neonSign(gx + 120, FLOOR_TOP - 145, 'GALLERIA V.E. II', '#f0c040');
    olympicBooth(gx + 400, FLOOR_TOP);
  }

  function drawSceneSforzesco(si) {
    const off = sceneOffset(si), cx = 150 - off * 0.5;
    // Castle walls
    ctx.fillStyle = '#b08060'; ctx.fillRect(cx, FLOOR_TOP - 100, 400, 100);
    // Battlements (crenellations)
    for (let i = 0; i < 20; i++) {
      ctx.fillStyle = '#a07050';
      ctx.fillRect(cx + i * 20, FLOOR_TOP - 112, 14, 14);
    }
    // Main tower (Filarete Tower)
    ctx.fillStyle = '#a87850'; ctx.fillRect(cx + 160, FLOOR_TOP - 200, 80, 100);
    ctx.fillStyle = '#987040';
    ctx.fillRect(cx + 165, FLOOR_TOP - 210, 70, 14);
    // Tower battlements
    for (let i = 0; i < 4; i++) ctx.fillRect(cx + 162 + i * 18, FLOOR_TOP - 222, 12, 14);
    // Clock
    ctx.fillStyle = '#f0e8d0'; ctx.beginPath(); ctx.arc(cx + 200, FLOOR_TOP - 170, 14, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#333'; ctx.fillRect(cx + 199, FLOOR_TOP - 180, 2, 12); ctx.fillRect(cx + 198, FLOOR_TOP - 170, 8, 2);
    // Gate arch
    ctx.fillStyle = '#5c3a1e'; ctx.fillRect(cx + 175, FLOOR_TOP - 60, 50, 60);
    ctx.beginPath(); ctx.arc(cx + 200, FLOOR_TOP - 60, 25, Math.PI, 0); ctx.fill();
    // Windows
    for (let i = 0; i < 6; i++) {
      ctx.fillStyle = '#5c4a3a'; ctx.fillRect(cx + 30 + i * 60, FLOOR_TOP - 75, 14, 20);
    }
    // Trees in courtyard
    for (let i = 0; i < 3; i++) {
      const tx = cx - 40 + i * 240;
      ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx, FLOOR_TOP - 40, 4, 40);
      ctx.fillStyle = '#3d8c3d'; ctx.beginPath(); ctx.arc(tx + 2, FLOOR_TOP - 48, 16, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawSceneArco(si) {
    const off = sceneOffset(si), ax = 250 - off * 0.5;
    // Arch structure
    ctx.fillStyle = '#d8d0c0'; ctx.fillRect(ax - 40, FLOOR_TOP - 150, 40, 150);
    ctx.fillRect(ax + 80, FLOOR_TOP - 150, 40, 150);
    ctx.fillRect(ax - 50, FLOOR_TOP - 160, 180, 15);
    // Arch opening
    ctx.fillStyle = '#d0c8b8';
    ctx.beginPath(); ctx.arc(ax + 40, FLOOR_TOP - 80, 40, Math.PI, 0); ctx.fill();
    ctx.fillRect(ax, FLOOR_TOP - 80, 80, 80);
    ctx.fillStyle = '#6080b0'; ctx.fillRect(ax + 5, FLOOR_TOP - 75, 70, 75);
    ctx.beginPath(); ctx.arc(ax + 40, FLOOR_TOP - 75, 35, Math.PI, 0); ctx.fill();
    // Top statues / chariot
    ctx.fillStyle = '#c8c0b0';
    ctx.fillRect(ax + 15, FLOOR_TOP - 180, 50, 20);
    ctx.fillStyle = '#b0a898';
    ctx.fillRect(ax + 25, FLOOR_TOP - 195, 30, 18);
    // Olympic flame on top!
    ctx.fillStyle = '#e05020';
    ctx.beginPath(); ctx.moveTo(ax + 40, FLOOR_TOP - 220);
    ctx.quadraticCurveTo(ax + 50, FLOOR_TOP - 200, ax + 40, FLOOR_TOP - 195);
    ctx.quadraticCurveTo(ax + 30, FLOOR_TOP - 200, ax + 40, FLOOR_TOP - 220); ctx.fill();
    ctx.fillStyle = '#f0c040';
    ctx.beginPath(); ctx.moveTo(ax + 40, FLOOR_TOP - 215);
    ctx.quadraticCurveTo(ax + 46, FLOOR_TOP - 203, ax + 40, FLOOR_TOP - 198);
    ctx.quadraticCurveTo(ax + 34, FLOOR_TOP - 203, ax + 40, FLOOR_TOP - 215); ctx.fill();
    // Flicker
    if (frame % 8 < 4) { ctx.fillStyle = '#ff8020'; ctx.beginPath(); ctx.arc(ax + 40 + Math.sin(frame * 0.2) * 3, FLOOR_TOP - 210, 4, 0, Math.PI * 2); ctx.fill(); }
    // Olympic rings nearby
    drawOlympicRings(ax - 60, FLOOR_TOP - 40, 6, 0.7);
    // Park with trees
    for (let i = 0; i < 4; i++) {
      const tx = ax - 120 + i * 100;
      if (tx < -30 || tx > W + 30) continue;
      ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx, FLOOR_TOP - 45, 4, 45);
      ctx.fillStyle = '#4a9c4a'; ctx.beginPath(); ctx.arc(tx + 2, FLOOR_TOP - 55, 18, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawSceneNavigli(si) {
    const off = sceneOffset(si), nx = 50 - off * 0.5;
    // Canal water
    ctx.fillStyle = '#3a7a5a'; ctx.fillRect(0, FLOOR_TOP - 30, W, 30);
    ctx.fillStyle = '#4a8a6a';
    for (let i = 0; i < W; i += 20) ctx.fillRect(i, FLOOR_TOP - 28 + Math.sin(frame * 0.07 + i * 0.06) * 2, 12, 2);
    // Canal walls
    ctx.fillStyle = '#888'; ctx.fillRect(0, FLOOR_TOP - 34, W, 4);
    // Colorful buildings along canal
    const colors = ['#e8a870','#d4c090','#c09070','#e0c0a0','#b89878','#d0b080','#c8a068'];
    for (let i = 0; i < 7; i++) {
      const bx = nx + i * 100;
      if (bx > W + 80 || bx + 70 < -80) continue;
      const h = 70 + (i % 3) * 20;
      ctx.fillStyle = colors[i]; ctx.fillRect(bx, FLOOR_TOP - 34 - h, 70, h);
      // Windows
      for (let r = 0; r < 3; r++) for (let c = 0; c < 2; c++) {
        ctx.fillStyle = Math.sin(frame * 0.01 + i + r) > 0 ? '#ffd86e' : '#4a5a3a';
        ctx.fillRect(bx + 10 + c * 35, FLOOR_TOP - 30 - h + 10 + r * 22, 12, 14);
      }
      // Balconies
      ctx.fillStyle = '#777'; ctx.fillRect(bx + 5, FLOOR_TOP - 34 - h + 50, 60, 2);
    }
    // Boats
    ctx.fillStyle = '#8b4513'; ctx.fillRect(nx + 200, FLOOR_TOP - 24 + Math.sin(frame * 0.04) * 2, 30, 6);
    olympicBooth(nx + 500, FLOOR_TOP - 34);
  }

  function drawSceneBrera(si) {
    const off = sceneOffset(si), bx = 60 - off * 0.5;
    // Pinacoteca di Brera building
    ctx.fillStyle = '#d0c0a8'; ctx.fillRect(bx, FLOOR_TOP - 120, 250, 120);
    // Courtyard arches
    for (let i = 0; i < 6; i++) {
      const ax2 = bx + 15 + i * 38;
      ctx.fillStyle = '#b0a088'; ctx.beginPath(); ctx.arc(ax2 + 10, FLOOR_TOP - 50, 16, Math.PI, 0); ctx.fill();
      ctx.fillRect(ax2, FLOOR_TOP - 50, 20, 50);
      ctx.fillStyle = '#4a3a2a'; ctx.fillRect(ax2 + 3, FLOOR_TOP - 45, 14, 45);
    }
    // Upper windows
    for (let i = 0; i < 8; i++) {
      ctx.fillStyle = '#8898a8'; ctx.fillRect(bx + 15 + i * 28, FLOOR_TOP - 105, 10, 16);
    }
    // Via Montenapoleone - luxury shops
    const shopCols = ['#333','#2a2a2a','#1a1a1a','#282828'];
    const brands = ['GUCCI', 'PRADA', 'ARMANI', 'VERSACE'];
    for (let i = 0; i < 4; i++) {
      const sx = bx + 300 + i * 95;
      if (sx > W + 80 || sx < -80) continue;
      ctx.fillStyle = shopCols[i]; ctx.fillRect(sx, FLOOR_TOP - 70, 75, 70);
      ctx.fillStyle = '#f0e8d0'; ctx.fillRect(sx + 5, FLOOR_TOP - 45, 65, 30);
      ctx.fillStyle = '#f0c040'; ctx.font = 'bold 7px monospace';
      ctx.fillText(brands[i], sx + 10, FLOOR_TOP - 52);
    }
  }

  function drawSceneCentrale(si) {
    const off = sceneOffset(si), sx = 100 - off * 0.5;
    // Massive station facade
    ctx.fillStyle = '#c8c0b0'; ctx.fillRect(sx, FLOOR_TOP - 150, 500, 150);
    // Grand arch entrance
    ctx.fillStyle = '#a8a098';
    ctx.beginPath(); ctx.arc(sx + 250, FLOOR_TOP - 80, 60, Math.PI, 0); ctx.fill();
    ctx.fillRect(sx + 190, FLOOR_TOP - 80, 120, 80);
    ctx.fillStyle = '#333'; ctx.fillRect(sx + 200, FLOOR_TOP - 70, 100, 70);
    // Side arches
    for (let i = 0; i < 2; i++) {
      const axx = sx + 70 + i * 300;
      ctx.fillStyle = '#a8a098'; ctx.beginPath(); ctx.arc(axx, FLOOR_TOP - 50, 30, Math.PI, 0); ctx.fill();
      ctx.fillRect(axx - 30, FLOOR_TOP - 50, 60, 50);
      ctx.fillStyle = '#444'; ctx.fillRect(axx - 20, FLOOR_TOP - 40, 40, 40);
    }
    // Towers at sides
    ctx.fillStyle = '#b8b0a0'; ctx.fillRect(sx - 10, FLOOR_TOP - 180, 35, 35);
    ctx.fillRect(sx + 475, FLOOR_TOP - 180, 35, 35);
    // Top ornament
    ctx.fillStyle = '#a0988a'; ctx.fillRect(sx + 100, FLOOR_TOP - 160, 300, 14);
    // Sign
    ctx.fillStyle = '#333'; ctx.fillRect(sx + 180, FLOOR_TOP - 165, 140, 12);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 8px monospace'; ctx.fillText('STAZIONE CENTRALE', sx + 190, FLOOR_TOP - 156);
    // Columns
    for (let i = 0; i < 10; i++) {
      ctx.fillStyle = '#b0a898'; ctx.fillRect(sx + 20 + i * 48, FLOOR_TOP - 148, 6, 148);
    }
    olympicBooth(sx + 520, FLOOR_TOP);
  }

  function drawSceneSanSiro(si) {
    const off = sceneOffset(si), sx = 150 - off * 0.5;
    // Stadium bowl shape
    ctx.fillStyle = '#7a8a9a'; ctx.fillRect(sx, FLOOR_TOP - 100, 350, 100);
    // Tiers
    ctx.fillStyle = '#8a9aaa'; ctx.fillRect(sx - 10, FLOOR_TOP - 110, 370, 14);
    ctx.fillStyle = '#6a7a8a'; ctx.fillRect(sx - 15, FLOOR_TOP - 120, 380, 14);
    // Support towers (4 cylindrical towers)
    for (let i = 0; i < 4; i++) {
      const tx = sx - 20 + i * 130;
      ctx.fillStyle = '#8898a8'; ctx.fillRect(tx, FLOOR_TOP - 140, 15, 140);
      ctx.fillStyle = '#7888a0'; ctx.beginPath(); ctx.arc(tx + 7, FLOOR_TOP - 140, 8, 0, Math.PI * 2); ctx.fill();
    }
    // Green pitch inside
    ctx.fillStyle = '#4a9c4a'; ctx.fillRect(sx + 30, FLOOR_TOP - 60, 290, 40);
    // Pitch lines
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
    ctx.strokeRect(sx + 35, FLOOR_TOP - 58, 280, 36);
    ctx.beginPath(); ctx.moveTo(sx + 175, FLOOR_TOP - 58); ctx.lineTo(sx + 175, FLOOR_TOP - 22); ctx.stroke();
    ctx.beginPath(); ctx.arc(sx + 175, FLOOR_TOP - 40, 12, 0, Math.PI * 2); ctx.stroke();
    // AC Milan / Inter flags
    ctx.fillStyle = '#e00020'; ctx.fillRect(sx + 50, FLOOR_TOP - 130, 12, 8);
    ctx.fillStyle = '#111'; ctx.fillRect(sx + 56, FLOOR_TOP - 130, 6, 8);
    ctx.fillStyle = '#0040a0'; ctx.fillRect(sx + 280, FLOOR_TOP - 130, 12, 8);
    ctx.fillStyle = '#111'; ctx.fillRect(sx + 286, FLOOR_TOP - 130, 6, 8);
    // Stadium label
    ctx.fillStyle = '#fff'; ctx.font = 'bold 8px monospace'; ctx.fillText('SAN SIRO', sx + 140, FLOOR_TOP - 95);
    drawOlympicRings(sx + 160, FLOOR_TOP - 85, 5, 0.5);
  }

  function drawSceneSantAmbrogio(si) {
    const off = sceneOffset(si), ax = 200 - off * 0.5;
    // Basilica facade
    ctx.fillStyle = '#c0a888'; ctx.fillRect(ax, FLOOR_TOP - 100, 200, 100);
    // Arched loggia (portico with arches)
    for (let i = 0; i < 4; i++) {
      const axx = ax + 20 + i * 45;
      ctx.fillStyle = '#a89878'; ctx.beginPath(); ctx.arc(axx + 10, FLOOR_TOP - 45, 18, Math.PI, 0); ctx.fill();
      ctx.fillRect(axx, FLOOR_TOP - 45, 20, 45);
      ctx.fillStyle = '#5c4a3a'; ctx.fillRect(axx + 3, FLOOR_TOP - 40, 14, 40);
    }
    // Bell tower
    ctx.fillStyle = '#b09070'; ctx.fillRect(ax + 210, FLOOR_TOP - 170, 30, 170);
    ctx.fillStyle = '#a08060';
    for (let i = 0; i < 3; i++) ctx.fillRect(ax + 215, FLOOR_TOP - 160 + i * 30, 20, 14);
    // Cross on top
    ctx.fillStyle = '#c0a050'; ctx.fillRect(ax + 223, FLOOR_TOP - 180, 4, 12);
    ctx.fillRect(ax + 219, FLOOR_TOP - 176, 12, 4);
    // Rose window
    ctx.fillStyle = '#6a8ab0'; ctx.beginPath(); ctx.arc(ax + 100, FLOOR_TOP - 75, 14, 0, Math.PI * 2); ctx.fill();
    // Trees
    for (let i = 0; i < 3; i++) {
      const tx = ax - 60 + i * 180;
      if (tx < -30 || tx > W + 30) continue;
      ctx.fillStyle = '#5c3a1e'; ctx.fillRect(tx, FLOOR_TOP - 40, 4, 40);
      ctx.fillStyle = '#3d8c3d'; ctx.beginPath(); ctx.arc(tx + 2, FLOOR_TOP - 50, 16, 0, Math.PI * 2); ctx.fill();
    }
    olympicBooth(ax - 100, FLOOR_TOP);
  }

  function drawSceneBoscoVerticale(si) {
    const off = sceneOffset(si), bx = 200 - off * 0.5;
    // Two towers
    for (let t = 0; t < 2; t++) {
      const tx = bx + t * 100;
      const h = t === 0 ? 250 : 200;
      ctx.fillStyle = '#c0c8c0'; ctx.fillRect(tx, FLOOR_TOP - h, 60, h);
      // Balconies with trees/bushes
      for (let r = 0; r < Math.floor(h / 20); r++) {
        ctx.fillStyle = '#888'; ctx.fillRect(tx - 4, FLOOR_TOP - h + 10 + r * 20, 68, 3);
        // Greenery on balconies
        const gc = r % 3 === 0 ? '#2d7c2d' : r % 3 === 1 ? '#3d8c3d' : '#4a9c4a';
        ctx.fillStyle = gc;
        ctx.beginPath(); ctx.arc(tx + 5, FLOOR_TOP - h + 8 + r * 20, 6, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(tx + 25, FLOOR_TOP - h + 6 + r * 20, 8, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(tx + 50, FLOOR_TOP - h + 7 + r * 20, 7, 0, Math.PI * 2); ctx.fill();
      }
    }
    // UnipolSai Tower nearby
    ctx.fillStyle = '#6080a0'; ctx.fillRect(bx + 250, FLOOR_TOP - 220, 35, 220);
    ctx.fillStyle = '#7090b0';
    for (let r = 0; r < 14; r++) ctx.fillRect(bx + 252, FLOOR_TOP - 215 + r * 15, 31, 8);
    // Curved top
    ctx.fillStyle = '#6080a0'; ctx.beginPath(); ctx.arc(bx + 267, FLOOR_TOP - 220, 18, Math.PI, 0); ctx.fill();
    // Esselunga supermarket
    ctx.fillStyle = '#e8e0d0'; ctx.fillRect(bx - 120, FLOOR_TOP - 50, 100, 50);
    ctx.fillStyle = '#e02020'; ctx.fillRect(bx - 115, FLOOR_TOP - 55, 90, 10);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 6px monospace'; ctx.fillText('esselunga', bx - 110, FLOOR_TOP - 47);
    olympicBooth(bx + 320, FLOOR_TOP);
  }

  function drawSceneColonne(si) {
    const off = sceneOffset(si), cx = 150 - off * 0.5;
    // Row of Roman columns
    for (let i = 0; i < 8; i++) {
      const colx = cx + 40 + i * 50;
      if (colx < -20 || colx > W + 20) continue;
      // Column base
      ctx.fillStyle = '#b0a898'; ctx.fillRect(colx - 2, FLOOR_TOP - 10, 14, 10);
      // Column shaft
      ctx.fillStyle = '#c8c0b0'; ctx.fillRect(colx, FLOOR_TOP - 110, 10, 100);
      // Column capital (Corinthian style)
      ctx.fillStyle = '#b8b0a0'; ctx.fillRect(colx - 3, FLOOR_TOP - 116, 16, 8);
      ctx.fillStyle = '#a8a090'; ctx.fillRect(colx - 1, FLOOR_TOP - 120, 12, 6);
      // Fluting on shaft
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.fillRect(colx + 3, FLOOR_TOP - 108, 1, 96);
      ctx.fillRect(colx + 6, FLOOR_TOP - 108, 1, 96);
    }
    // Architrave connecting columns
    ctx.fillStyle = '#b0a898'; ctx.fillRect(cx + 35, FLOOR_TOP - 124, 400, 6);
    // Basilica di San Lorenzo behind
    ctx.fillStyle = '#a89878'; ctx.fillRect(cx + 450, FLOOR_TOP - 100, 150, 100);
    ctx.fillStyle = '#988868';
    ctx.beginPath(); ctx.arc(cx + 525, FLOOR_TOP - 100, 50, Math.PI, 0); ctx.fill();
    // Dome
    ctx.fillStyle = '#8a7858'; ctx.beginPath(); ctx.arc(cx + 525, FLOOR_TOP - 120, 30, Math.PI, 0); ctx.fill();
    // Cross on dome
    ctx.fillStyle = '#c0a050'; ctx.fillRect(cx + 523, FLOOR_TOP - 155, 4, 12);
    ctx.fillRect(cx + 519, FLOOR_TOP - 151, 12, 4);
    // Park grass area
    ctx.fillStyle = '#4a8c4a'; ctx.fillRect(cx, FLOOR_TOP - 3, 440, 3);
    olympicBooth(cx - 30, FLOOR_TOP);
  }

  function drawSceneSantaGiulia(si) {
    const off = sceneOffset(si), ax = 100 - off * 0.5;
    // Modern arena - curved roof
    ctx.fillStyle = '#6080a0'; ctx.fillRect(ax, FLOOR_TOP - 80, 400, 80);
    ctx.fillStyle = '#5070a0';
    ctx.beginPath(); ctx.ellipse(ax + 200, FLOOR_TOP - 80, 210, 50, 0, Math.PI, 0); ctx.fill();
    // Glass panels
    ctx.fillStyle = 'rgba(150,200,255,0.3)';
    for (let i = 0; i < 10; i++) ctx.fillRect(ax + 20 + i * 38, FLOOR_TOP - 75, 28, 60);
    // ICE HOCKEY label
    ctx.fillStyle = '#fff'; ctx.font = 'bold 10px monospace'; ctx.textAlign = 'center';
    ctx.fillText('SANTA GIULIA ARENA', ax + 200, FLOOR_TOP - 90);
    ctx.fillStyle = '#0081C8'; ctx.font = 'bold 8px monospace';
    ctx.fillText('ICE HOCKEY', ax + 200, FLOOR_TOP - 100);
    ctx.textAlign = 'left';
    // Olympic rings on building
    drawOlympicRings(ax + 170, FLOOR_TOP - 40, 8, 0.6);
    // Olympic flags
    for (let i = 0; i < 3; i++) {
      const fx = ax - 30 + i * 200;
      if (fx < -20 || fx > W + 20) continue;
      ctx.fillStyle = '#888'; ctx.fillRect(fx, FLOOR_TOP - 60, 3, 60);
      ctx.fillStyle = '#fff'; ctx.fillRect(fx + 3, FLOOR_TOP - 58, 18, 12);
      drawOlympicRings(fx + 5, FLOOR_TOP - 52, 2, 0.9);
    }
    olympicBooth(ax + 430, FLOOR_TOP);
    olympicBooth(ax - 60, FLOOR_TOP);
  }

  function drawSceneAssago(si) {
    const off = sceneOffset(si), ax = 120 - off * 0.5;
    // Assago Forum - large dome structure
    ctx.fillStyle = '#808898'; ctx.fillRect(ax, FLOOR_TOP - 70, 450, 70);
    ctx.fillStyle = '#707888';
    ctx.beginPath(); ctx.ellipse(ax + 225, FLOOR_TOP - 70, 230, 80, 0, Math.PI, 0); ctx.fill();
    // Metal ribs on dome
    ctx.strokeStyle = '#606878'; ctx.lineWidth = 1;
    for (let i = 0; i < 12; i++) {
      const ang = Math.PI + (i / 11) * Math.PI;
      const rx = ax + 225 + Math.cos(ang) * 220;
      const ry = FLOOR_TOP - 70 + Math.sin(ang) * 75;
      ctx.beginPath(); ctx.moveTo(ax + 225, FLOOR_TOP - 70); ctx.lineTo(rx, ry); ctx.stroke();
    }
    // Entrance
    ctx.fillStyle = '#5a6a7a'; ctx.fillRect(ax + 180, FLOOR_TOP - 50, 90, 50);
    ctx.fillStyle = 'rgba(150,200,255,0.4)'; ctx.fillRect(ax + 185, FLOOR_TOP - 48, 80, 35);
    // ICE SKATING label
    ctx.fillStyle = '#fff'; ctx.font = 'bold 10px monospace'; ctx.textAlign = 'center';
    ctx.fillText('ASSAGO FORUM', ax + 225, FLOOR_TOP - 110);
    ctx.fillStyle = '#FCB131'; ctx.font = 'bold 8px monospace';
    ctx.fillText('FIGURE SKATING', ax + 225, FLOOR_TOP - 120);
    ctx.textAlign = 'left';
    drawOlympicRings(ax + 195, FLOOR_TOP - 95, 8, 0.6);
    // Olympic pop-ups on sides
    olympicBooth(ax - 50, FLOOR_TOP);
    olympicBooth(ax + 480, FLOOR_TOP);
    // Esselunga nearby
    ctx.fillStyle = '#e8e0d0'; ctx.fillRect(ax + 530, FLOOR_TOP - 45, 80, 45);
    ctx.fillStyle = '#e02020'; ctx.fillRect(ax + 535, FLOOR_TOP - 50, 70, 8);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 6px monospace'; ctx.fillText('esselunga', ax + 540, FLOOR_TOP - 42);
  }

  // ============================================================
  // FLOOR & SKY
  // ============================================================
  function drawFloor() {
    ctx.fillStyle = '#b0a090'; ctx.fillRect(0, FLOOR_TOP, W, FLOOR_BOT - FLOOR_TOP + 20);
    ctx.fillStyle = '#a09080';
    for (let i = 0; i < W + 60; i += 50) ctx.fillRect(i - (worldX % 50), FLOOR_TOP, 1, FLOOR_BOT - FLOOR_TOP + 20);
    for (let j = 0; j < 4; j++) ctx.fillRect(0, FLOOR_TOP + j * 35, W, 1);
    ctx.fillStyle = '#444'; ctx.fillRect(0, FLOOR_BOT + 20, W, 60);
    ctx.fillStyle = '#ff0'; for (let i = 0; i < W + 60; i += 50) ctx.fillRect(i - (worldX % 50), FLOOR_BOT + 45, 25, 3);
  }
  function drawSky() {
    const grad = ctx.createLinearGradient(0, 0, 0, FLOOR_TOP);
    grad.addColorStop(0, '#0a0a2e'); grad.addColorStop(0.3, '#1a1b50');
    grad.addColorStop(0.6, '#c06070'); grad.addColorStop(1, '#f0b858');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, W, FLOOR_TOP + 5);
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 25; i++) { const sx = (42 * (i+1) * 7) % W, sy = (42 * (i+1) * 13) % 80; if (Math.sin(frame * 0.04 + i) > 0.2) ctx.fillRect(sx, sy, 2, 2); }
  }
  function drawSkyShanghai() {
    const grad = ctx.createLinearGradient(0, 0, 0, FLOOR_TOP);
    grad.addColorStop(0, '#0a1a2e'); grad.addColorStop(0.3, '#1a2b50');
    grad.addColorStop(0.6, '#2a4060'); grad.addColorStop(1, '#405878');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, W, FLOOR_TOP + 5);
    // More stars, slightly hazy
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    for (let i = 0; i < 30; i++) { const sx = (37 * (i+1) * 11) % W, sy = (37 * (i+1) * 7) % 70; if (Math.sin(frame * 0.03 + i * 1.5) > 0.3) ctx.fillRect(sx, sy, 2, 2); }
    // Haze/smog layer
    ctx.fillStyle = 'rgba(80,100,120,0.15)'; ctx.fillRect(0, FLOOR_TOP - 50, W, 50);
  }

  // ============================================================
  // FOOD DRAWING
  // ============================================================
  function drawFoodItem(f) {
    const fx = f.wx - worldX, fy = f.y;
    if (fx < -30 || fx > W + 30) return;
    const bob = Math.sin(frame * 0.08 + f.wx * 0.05) * 2;
    if (f.type === 'fishbone') { ctx.fillStyle = '#ddd'; ctx.fillRect(fx, fy + bob, 22, 3); for (let i = 0; i < 5; i++) { ctx.fillRect(fx + 2 + i * 4, fy - 4 + bob, 2, 5); ctx.fillRect(fx + 2 + i * 4, fy + 3 + bob, 2, 5); } ctx.fillStyle = '#bbb'; ctx.beginPath(); ctx.arc(fx + 24, fy + 1 + bob, 4, 0, Math.PI * 2); ctx.fill();
    } else if (f.type === 'wrapper') { ctx.fillStyle = '#c0a050'; ctx.fillRect(fx, fy + bob, 18, 12); ctx.fillStyle = '#e0c060'; ctx.fillRect(fx + 2, fy + 2 + bob, 6, 4); ctx.fillStyle = '#a08030'; ctx.fillRect(fx + 10, fy + 6 + bob, 6, 4);
    } else if (f.type === 'banana') { ctx.fillStyle = '#f0d040'; ctx.beginPath(); ctx.ellipse(fx + 10, fy + 4 + bob, 12, 5, 0.3, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#8b6914'; ctx.fillRect(fx + 20, fy + bob, 3, 3);
    } else if (f.type === 'can') { ctx.fillStyle = '#c0c0c0'; ctx.fillRect(fx, fy - 2 + bob, 12, 14); ctx.fillStyle = '#e05050'; ctx.fillRect(fx, fy + bob, 12, 8); ctx.fillStyle = '#ddd'; ctx.fillRect(fx + 2, fy - 3 + bob, 8, 2);
    } else if (f.type === 'xlb') {
      // Xiaolongbao - steamed dumpling
      ctx.fillStyle = '#f5e8d0'; ctx.beginPath(); ctx.arc(fx + 10, fy + 4 + bob, 9, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#e8d4b0'; ctx.beginPath(); ctx.arc(fx + 10, fy + 6 + bob, 9, 0, Math.PI); ctx.fill();
      // Pleats on top
      ctx.fillStyle = '#d4c0a0';
      for (let p = 0; p < 5; p++) ctx.fillRect(fx + 5 + p * 2, fy - 2 + bob, 1, 3);
      ctx.fillStyle = '#c8a878'; ctx.fillRect(fx + 8, fy - 4 + bob, 4, 3);
      // Steam
      if (frame % 30 < 20) { ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(fx + 7, fy - 8 + bob - (frame % 10), 2, 3); ctx.fillRect(fx + 12, fy - 10 + bob - (frame % 12), 2, 3); }
    } else if (f.type === 'firecracker') {
      // Red firecracker
      ctx.fillStyle = '#e83030'; ctx.fillRect(fx + 3, fy + bob, 14, 10);
      ctx.fillStyle = '#cc2020'; ctx.fillRect(fx + 3, fy + 3 + bob, 14, 4);
      ctx.fillStyle = '#f0c040'; ctx.fillRect(fx + 4, fy + 1 + bob, 3, 2); ctx.fillRect(fx + 12, fy + 1 + bob, 3, 2);
      // Fuse
      ctx.strokeStyle = '#888'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(fx + 10, fy + bob); ctx.lineTo(fx + 10, fy - 6 + bob); ctx.stroke();
      // Sparks
      if (frame % 16 < 8) { ctx.fillStyle = '#ff0'; ctx.fillRect(fx + 9, fy - 8 + bob, 2, 2); ctx.fillRect(fx + 12, fy - 7 + bob, 2, 2); }
    } else if (f.type === 'cabbage') {
      // Chinese cabbage / bok choy
      ctx.fillStyle = '#f0f0e0'; ctx.fillRect(fx + 5, fy + 2 + bob, 8, 10);
      ctx.fillStyle = '#4a9c4a'; ctx.beginPath(); ctx.ellipse(fx + 6, fy - 2 + bob, 6, 7, -0.3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#3d8c3d'; ctx.beginPath(); ctx.ellipse(fx + 13, fy - 1 + bob, 5, 6, 0.3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#5aac5a'; ctx.beginPath(); ctx.ellipse(fx + 9, fy - 4 + bob, 4, 5, 0, 0, Math.PI * 2); ctx.fill();
    } else if (f.type === 'pizza') {
      // Pizza slice
      ctx.fillStyle = '#e8c840'; ctx.beginPath(); ctx.moveTo(fx + 10, fy - 6 + bob);
      ctx.lineTo(fx + 22, fy + 10 + bob); ctx.lineTo(fx - 2, fy + 10 + bob); ctx.fill();
      ctx.fillStyle = '#e05030'; // sauce
      ctx.beginPath(); ctx.moveTo(fx + 10, fy - 2 + bob);
      ctx.lineTo(fx + 18, fy + 8 + bob); ctx.lineTo(fx + 2, fy + 8 + bob); ctx.fill();
      ctx.fillStyle = '#f0e8c0'; // cheese blobs
      ctx.beginPath(); ctx.arc(fx + 8, fy + 3 + bob, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(fx + 13, fy + 5 + bob, 2, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#4a8c4a'; ctx.fillRect(fx + 10, fy + 1 + bob, 2, 2); // basil
    } else if (f.type === 'gelato') {
      // Gelato cone
      ctx.fillStyle = '#d4a050'; ctx.beginPath(); ctx.moveTo(fx + 5, fy - 2 + bob);
      ctx.lineTo(fx + 15, fy - 2 + bob); ctx.lineTo(fx + 10, fy + 12 + bob); ctx.fill();
      // Cross pattern on cone
      ctx.strokeStyle = '#c09040'; ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(fx + 6, fy + bob); ctx.lineTo(fx + 14, fy + 8 + bob); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(fx + 14, fy + bob); ctx.lineTo(fx + 6, fy + 8 + bob); ctx.stroke();
      // Scoops
      ctx.fillStyle = '#f5a0b0'; ctx.beginPath(); ctx.arc(fx + 8, fy - 5 + bob, 5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#a0d850'; ctx.beginPath(); ctx.arc(fx + 14, fy - 4 + bob, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#f0e0b0'; ctx.beginPath(); ctx.arc(fx + 10, fy - 9 + bob, 4, 0, Math.PI * 2); ctx.fill();
    } else if (f.type === 'spaghetti') {
      // Spaghetti with meatballs
      ctx.fillStyle = '#f0e0b0'; ctx.beginPath(); ctx.ellipse(fx + 10, fy + 4 + bob, 11, 7, 0, 0, Math.PI * 2); ctx.fill();
      // Noodle lines
      ctx.strokeStyle = '#e8d090'; ctx.lineWidth = 1;
      for (let n = 0; n < 4; n++) {
        ctx.beginPath(); ctx.moveTo(fx + 2 + n * 4, fy + bob);
        ctx.quadraticCurveTo(fx + 4 + n * 4, fy + 6 + bob, fx + 6 + n * 4, fy + 2 + bob); ctx.stroke();
      }
      // Sauce
      ctx.fillStyle = '#c83020'; ctx.beginPath(); ctx.ellipse(fx + 10, fy + 2 + bob, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
      // Meatballs
      ctx.fillStyle = '#8b4513'; ctx.beginPath(); ctx.arc(fx + 6, fy + 2 + bob, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(fx + 14, fy + 1 + bob, 3, 0, Math.PI * 2); ctx.fill();
    }
    if (Math.sin(frame * 0.1 + f.wx) > 0.65) { ctx.fillStyle = '#fff'; ctx.fillRect(fx + 16, fy - 7 + bob, 3, 3); }
  }

  // ============================================================
  // HUD
  // ============================================================
  function drawHUD() {
    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, W, 32);
    for (let i = 0; i < 8; i++) {
      ctx.fillStyle = i % 2 ? '#e8c040' : '#333';
      ctx.beginPath(); ctx.moveTo(i * 12, 0); ctx.lineTo(i * 12 + 12, 0); ctx.lineTo(i * 12, 32); ctx.lineTo(i * 12 - 12, 32); ctx.fill();
      const rx = W - i * 12;
      ctx.beginPath(); ctx.moveTo(rx, 0); ctx.lineTo(rx - 12, 0); ctx.lineTo(rx, 32); ctx.lineTo(rx + 12, 32); ctx.fill();
    }
    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(90, 0, W - 180, 32);
    ctx.fillStyle = '#5dade2'; ctx.font = 'bold 14px monospace'; ctx.fillText(playerName || '1P', 100, 20);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 16px monospace'; ctx.fillText(String(score).padStart(6, '0'), 130, 20);
    for (let i = 0; i < player.maxHp; i++) drawHeart(260 + i * 24, 6, i < player.hp ? '#e74c3c' : '#333');
    ctx.fillStyle = '#5dade2'; ctx.font = 'bold 10px monospace'; ctx.textAlign = 'center'; ctx.fillText('HI', W / 2, 12);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 14px monospace'; ctx.fillText(String(hiScore).padStart(6, '0'), W / 2, 26); ctx.textAlign = 'left';
    const si = Math.floor(worldX / SCENE_W);
    const sn = si < levelScenes.length ? levelScenes[si].name : '';
    ctx.fillStyle = '#5dade2'; ctx.font = 'bold 10px monospace'; ctx.textAlign = 'right';
    ctx.fillText('LV' + (currentLevel + 1) + ' ' + LEVEL_NAMES[currentLevel], W - 100, 12); ctx.textAlign = 'left';
    if (sn) { ctx.fillStyle = '#f0c040'; ctx.font = 'bold 11px monospace'; ctx.textAlign = 'right'; ctx.fillText(sn, W - 100, 26); ctx.textAlign = 'left'; }
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(8, H - 14, W - 16, 10);
    const lvFrac = 1 / LEVELS.length;
    const totalProgress = currentLevel * lvFrac + (worldX / WORLD_END) * lvFrac;
    ctx.fillStyle = '#f0c040'; ctx.fillRect(10, H - 12, (W - 20) * Math.min(1, totalProgress), 6);
  }
  function drawHeart(x, y, color) {
    ctx.fillStyle = color; ctx.beginPath();
    ctx.arc(x + 5, y + 5, 6, 0, Math.PI * 2); ctx.arc(x + 14, y + 5, 6, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x - 1, y + 8); ctx.lineTo(x + 10, y + 20); ctx.lineTo(x + 20, y + 8); ctx.closePath(); ctx.fill();
  }

  // ============================================================
  // TITLE
  // ============================================================
  function drawTitle() {
    drawSky(); drawFloor();
    px(chowderR1, W / 2 - 35, H / 2 - 50, 5);
    ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 50, W, 55);
    ctx.fillStyle = '#f0c040'; ctx.font = 'bold 24px monospace'; ctx.textAlign = 'center';
    ctx.fillText("CHOWDER'S ADVENTURE", W / 2, 85);
    if (playerName) {
      ctx.fillStyle = '#5dade2'; ctx.font = 'bold 14px monospace';
      ctx.fillText('PLAYER: ' + playerName, W / 2, H / 2 + 50);
    }
    ctx.fillStyle = '#fff'; ctx.font = '12px monospace';
    ctx.fillText(isMobile ? 'Tap to start!' : 'Press SPACE to start', W / 2, H / 2 + 70);
    ctx.fillStyle = '#888'; ctx.font = '10px monospace';
    ctx.fillText(isMobile ? 'Use buttons to move & bark!' : 'Arrows: Move | Space: Bark Attack | Eat scraps for HP!', W / 2, H / 2 + 88);
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, W, 32);
    for (let i = 0; i < Math.ceil(W / 12) + 1; i++) {
      ctx.fillStyle = i % 2 ? '#e8c040' : '#333';
      ctx.beginPath(); ctx.moveTo(i * 12, 0); ctx.lineTo(i * 12 + 12, 0); ctx.lineTo(i * 12, 32); ctx.lineTo(i * 12 - 12, 32); ctx.fill();
    }
    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(90, 2, W - 180, 28);
    ctx.fillStyle = '#5dade2'; ctx.font = 'bold 16px monospace'; ctx.textAlign = 'center';
    ctx.fillText('INSERT COIN', W / 2, 22); ctx.textAlign = 'left';
  }

  // ============================================================
  // UPDATE
  // ============================================================
  function update() {
    if (gameState === 'levelComplete') {
      levelCompleteTimer--;
      if (levelCompleteTimer <= 0) startNextLevel();
      return;
    }
    if (gameState !== 'playing') return;
    frame++; worldX += SCROLL_SPEED;
    if (worldX >= WORLD_END) {
      if (currentLevel < LEVELS.length - 1) {
        gameState = 'levelComplete'; stopMusic(); levelCompleteTimer = 90; return;
      } else {
        gameState = 'win'; stopMusic(); if (score > hiScore) hiScore = score; addToLeaderboard(playerName, score); showLeaderboard = true; return;
      }
    }

    const spd = 3;
    if (keys['ArrowUp'] || keys['w'] || touchKeys.up) player.y = Math.max(FLOOR_TOP + 10, player.y - spd);
    if (keys['ArrowDown'] || keys['s'] || touchKeys.down) player.y = Math.min(FLOOR_BOT, player.y + spd);

    if (player.atkTimer > 0) { player.atkTimer--; if (player.atkTimer <= 0) player.attacking = false; }
    if (player.invTimer > 0) player.invTimer--;
    player.animTimer++; if (player.animTimer > 8) { player.animTimer = 0; player.animFrame ^= 1; }

    if (worldX > nextEnemy) spawnEnemy();
    if (worldX > nextFood) spawnFood();

    for (const e of enemies) {
      if (!e.alive) continue;
      e.wx -= e.spd; e.at++; if (e.at > 10) { e.at = 0; e.af ^= 1; }
      if (e.hitFlash > 0) e.hitFlash--;

      const ex = e.wx - worldX;
      const dx = PLAYER_X + 20 - ex, dy = player.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (player.attacking && player.atkTimer > 10 && dist < (e.isThug ? 80 : 70) && !e.invincible) {
        if (e.hitFlash <= 0) {
          e.hp--;
          e.hitFlash = 12;
          if (e.hp <= 0) {
            e.alive = false;
            const pts = e.enemyType === 'ultra' ? 200 : e.enemyType === 'rider' ? 300 : e.isThug ? 200 : e.enemyType === 'cat' ? 75 : 50;
            score += pts;
            particle(ex, e.y - 20, '#f0c040', '+' + pts);
            playKO();
            for (let i = 0; i < 6; i++) particles.push({ x: ex + Math.random() * 30 - 10, y: e.y - 10 + Math.random() * 20, col: '#f0c040', txt: '*', life: 18, vy: -3 + Math.random() * 6, vx: -2 + Math.random() * 4 });
          } else {
            playHit();
            particle(ex + 10, e.y - 25, '#ff8800', `${e.hp}/${e.maxHp}`);
          }
        }
        continue;
      }

      const hitDist = e.enemyType === 'tram' ? 65 : e.isThug ? 50 : 45;
      if (dist < hitDist && player.invTimer <= 0 && !player.attacking) {
        player.hp--;
        player.invTimer = 60;
        particle(PLAYER_X, player.y - 30, '#e74c3c', '-1 HP');
        playWhimper();
        if (player.hp <= 0) { if (score > hiScore) hiScore = score; addToLeaderboard(playerName, score); showLeaderboard = true; gameState = 'gameover'; stopMusic(); playKO(); }
      }
    }
    enemies = enemies.filter(e => (e.wx - worldX) > -100);

    for (const f of food) {
      if (f.collected) continue;
      const fx = f.wx - worldX, dx = PLAYER_X + 20 - fx, dy = player.y - f.y;
      if (Math.sqrt(dx * dx + dy * dy) < 40) {
        f.collected = true; score += 10;
        particle(fx, f.y - 10, '#f0c040', '+10');
        if (player.hp < player.maxHp) { player.hp++; particle(fx, f.y - 25, '#2ecc71', '+1 HP'); }
        playBurp();
      }
    }
    food = food.filter(f => (f.wx - worldX) > -100);

    for (const p of particles) { p.y += (p.vy || -1.5); if (p.vx) p.x += p.vx; p.life--; }
    particles = particles.filter(p => p.life > 0);
  }

  // ============================================================
  // DRAW
  // ============================================================
  function draw() {
    ctx.clearRect(0, 0, W, H);
    if (gameState === 'title') { drawTitle(); return; }
    if (currentLevel === 0) drawSky(); else if (currentLevel === 1) drawSkyShanghai(); else drawSkyMilan();
    const si = Math.floor(worldX / SCENE_W);
    for (let i = si - 1; i <= si + 1; i++) {
      if (i >= 0 && i < levelScenes.length) {
        const lo = worldX - i * SCENE_W;
        if (lo > -W && lo < SCENE_W + W) levelScenes[i].draw(i);
      }
    }
    drawFloor();

    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath();
    ctx.ellipse(PLAYER_X + 25, player.y + 35, 25, 6, 0, 0, Math.PI * 2); ctx.fill();

    for (const f of food) if (!f.collected) drawFoodItem(f);

    const entities = [];
    entities.push({ type: 'player', y: player.y });
    for (const e of enemies) if (e.alive) entities.push({ type: 'enemy', ref: e, y: e.y });
    entities.sort((a, b) => a.y - b.y);

    for (const ent of entities) {
      if (ent.type === 'player') {
        if (player.invTimer <= 0 || Math.floor(player.invTimer / 3) % 2 === 0) {
          const spr = player.attacking ? chowderAtk : chowderFrames[player.animFrame];
          px(spr, PLAYER_X, player.y - 40, SPRITE_S);
          if (player.attacking && player.atkTimer > 10) {
            ctx.save(); ctx.globalAlpha = 0.5; ctx.strokeStyle = '#f0c040'; ctx.lineWidth = 4;
            const t = (20 - player.atkTimer) / 10;
            ctx.beginPath(); ctx.arc(PLAYER_X + 55, player.y, 30 + t * 15, -0.8, 0.8); ctx.stroke();
            ctx.globalAlpha = 0.3; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(PLAYER_X + 55, player.y, 25 + t * 20, -0.5, 0.5); ctx.stroke();
            ctx.globalAlpha = 0.8 - t * 0.5; ctx.fillStyle = '#f0c040'; ctx.font = 'bold 18px monospace';
            ctx.fillText('BARK!', PLAYER_X + 70, player.y - 15 - t * 10);
            ctx.restore();
          }
        }
      } else {
        const e = ent.ref;
        const ex = e.wx - worldX;
        if (ex < -60 || ex > W + 60) continue;
        if (e.hitFlash > 0) { ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(e.hitFlash * 2) * 0.3; }

        if (e.enemyType === 'tram') {
          ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath();
          ctx.ellipse(ex + 50, e.y + 30, 52, 8, 0, 0, Math.PI * 2); ctx.fill();
          px(tramFrames[e.af], ex, e.y - 25, TRAM_S);
          // Overhead wire
          ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(ex + 50, e.y - 35); ctx.lineTo(ex + 50, e.y - 80); ctx.stroke();
        } else if (e.enemyType === 'ultra') {
          ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.beginPath();
          ctx.ellipse(ex + 25, e.y + 28, 26, 6, 0, 0, Math.PI * 2); ctx.fill();
          px(ultraFrames[e.af], ex, e.y - 30, ULTRA_S, ULTRA_COLORS[e.variant]);
        } else if (e.enemyType === 'cat') {
          ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.beginPath();
          ctx.ellipse(ex + 20, e.y + 20, 18, 4, 0, 0, Math.PI * 2); ctx.fill();
          px(catFrames[e.af], ex, e.y - 22, CAT_S, CAT_COLORS[e.variant]);
        } else if (e.enemyType === 'rider') {
          ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.beginPath();
          ctx.ellipse(ex + 30, e.y + 30, 32, 7, 0, 0, Math.PI * 2); ctx.fill();
          px(riderFrames[e.af], ex, e.y - 35, RIDER_S, RIDER_COLORS[e.variant]);
        } else {
          const sc = e.isThug ? THUG_S : DOG_S;
          ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.beginPath();
          ctx.ellipse(ex + 25, e.y + 25, e.isThug ? 30 : 22, e.isThug ? 7 : 5, 0, 0, Math.PI * 2); ctx.fill();
          px(dogFrames[e.af], ex, e.y - (e.isThug ? 40 : 25), sc, DOG_COLORS[e.variant]);
        }
        if (e.hitFlash > 0) ctx.restore();
        if (e.isThug) {
          const label = e.enemyType === 'tram' ? 'TRAM!' : e.enemyType === 'ultra' ? 'ULTRA' : e.enemyType === 'rider' ? 'RIDER' : 'THUG';
          const labelCol = e.enemyType === 'tram' ? '#e8a020' : e.enemyType === 'ultra' ? (e.variant === 'ac' ? '#e00020' : '#0040a0') : e.enemyType === 'rider' ? '#2080ff' : '#e74c3c';
          ctx.fillStyle = labelCol; ctx.font = 'bold 10px monospace';
          ctx.fillText(label, ex + 10, e.y - 45);
          ctx.fillStyle = '#333'; ctx.fillRect(ex + 5, e.y - 40, 50, 5);
          ctx.fillStyle = labelCol; ctx.fillRect(ex + 5, e.y - 40, 50 * (e.hp / e.maxHp), 5);
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(ex + 5, e.y - 40, 50, 5);
        }
      }
    }

    for (const p of particles) {
      ctx.globalAlpha = p.life / 45; ctx.fillStyle = p.col;
      ctx.font = 'bold 14px monospace'; ctx.fillText(p.txt, p.x, p.y);
    }
    ctx.globalAlpha = 1;
    drawHUD();

    if (gameState === 'levelComplete') {
      ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0, 0, W, H);
      ctx.textAlign = 'center';
      ctx.fillStyle = '#f0c040'; ctx.font = 'bold 28px monospace';
      ctx.fillText('LEVEL ' + (currentLevel + 1) + ' COMPLETE!', W / 2, H / 2 - 50);
      ctx.fillStyle = '#5dade2'; ctx.font = 'bold 18px monospace';
      ctx.fillText(LEVEL_NAMES[currentLevel] + ' CLEARED!', W / 2, H / 2 - 15);
      ctx.fillStyle = '#fff'; ctx.font = 'bold 22px monospace';
      const nextLvName = currentLevel + 1 < LEVEL_NAMES.length ? LEVEL_NAMES[currentLevel + 1] : '???';
      ctx.fillText('NEXT: ' + nextLvName, W / 2, H / 2 + 30);
      ctx.fillStyle = '#888'; ctx.font = '14px monospace';
      const dots = '.'.repeat(Math.floor(frame / 15) % 4);
      ctx.fillText('Loading' + dots, W / 2, H / 2 + 65);
      px(chowderFrames[Math.floor(frame / 10) % 2], W / 2 - 35, H / 2 + 80, 4);
      ctx.textAlign = 'left';
    }

    if (gameState === 'gameover' || gameState === 'win') {
      ctx.fillStyle = 'rgba(0,0,0,0.82)'; ctx.fillRect(0, 0, W, H);
      ctx.textAlign = 'center';

      if (gameState === 'gameover') {
        ctx.fillStyle = '#e74c3c'; ctx.font = 'bold 30px monospace';
        ctx.fillText('GAME OVER', W / 2, 42);
      } else {
        ctx.fillStyle = '#f0c040'; ctx.font = 'bold 30px monospace';
        ctx.fillText('CHOWDER WINS!', W / 2, 42);
        ctx.fillStyle = '#5dade2'; ctx.font = 'bold 14px monospace';
        ctx.fillText('ALL LEVELS CLEARED!', W / 2, 58);
      }

      // Your score
      ctx.fillStyle = '#fff'; ctx.font = 'bold 16px monospace';
      ctx.fillText(`${playerName}  ${String(score).padStart(6, '0')}`, W / 2, 70);

      // Leaderboard
      if (showLeaderboard) {
        const bx = W / 2 - 160, by = 88, bw = 320, bh = 330;
        // Border
        ctx.fillStyle = '#1a1a3a'; ctx.fillRect(bx, by, bw, bh);
        ctx.strokeStyle = '#f0c040'; ctx.lineWidth = 2; ctx.strokeRect(bx, by, bw, bh);
        // Header
        ctx.fillStyle = '#f0c040'; ctx.font = 'bold 16px monospace';
        ctx.fillText('TOP  10  SCORES', W / 2, by + 24);
        // Column headers
        ctx.fillStyle = '#5dade2'; ctx.font = 'bold 11px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('RNK', bx + 14, by + 48);
        ctx.fillText('NAME', bx + 60, by + 48);
        ctx.fillText('SCORE', bx + 180, by + 48);
        // Separator line
        ctx.fillStyle = '#f0c040'; ctx.fillRect(bx + 10, by + 54, bw - 20, 1);
        // Entries
        const board = leaderboard.slice(0, 10);
        for (let i = 0; i < 10; i++) {
          const ey = by + 70 + i * 25;
          const entry = board[i];
          // Highlight if this is the current score
          const isCurrent = entry && entry.score === score && entry.name === playerName && entry.date && (Date.now() - entry.date < 5000);
          if (isCurrent) {
            ctx.fillStyle = 'rgba(240,192,64,0.15)'; ctx.fillRect(bx + 4, ey - 14, bw - 8, 22);
          }
          // Rank
          const rankColors = ['#f0c040', '#c0c0c0', '#cd7f32']; // gold, silver, bronze
          ctx.fillStyle = i < 3 ? rankColors[i] : '#888';
          ctx.font = 'bold 14px monospace';
          ctx.textAlign = 'left';
          ctx.fillText(`${i + 1}.`, bx + 14, ey);
          if (entry) {
            // Name
            ctx.fillStyle = isCurrent ? '#f0c040' : '#fff';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(entry.name, bx + 60, ey);
            // Score
            ctx.fillStyle = isCurrent ? '#f0c040' : '#ddd';
            ctx.fillText(String(entry.score).padStart(6, '0'), bx + 180, ey);
          } else {
            ctx.fillStyle = '#444'; ctx.font = '14px monospace';
            ctx.fillText('---', bx + 60, ey);
            ctx.fillText('------', bx + 180, ey);
          }
        }
      }

      // Retry prompt
      ctx.textAlign = 'center';
      ctx.fillStyle = '#888'; ctx.font = '12px monospace';
      const retryY = showLeaderboard ? H - 18 : H / 2 + 80;
      ctx.fillText(isMobile ? 'Tap to play again' : 'Press R or SPACE to play again', W / 2, retryY);
      ctx.textAlign = 'left';
    }
  }

  // ============================================================
  // LOOP
  // ============================================================
  function loop() { update(); draw(); requestAnimationFrame(loop); }
  loop();
})();
</script>
</body>
</html>
